{"version":3,"file":"module.js","sources":["../../src/ts/constants.ts","../../src/ts/utils/logger.ts","../../src/ts/types.ts","../../src/ts/network/webSocketManager.ts","../../src/ts/utils/search.ts","../../src/ts/utils/serialization.ts","../../src/ts/network/webSocketEndpoints.ts","../../src/ts/module.ts"],"sourcesContent":["import { id } from \"../module.json\";\n\nexport const moduleId = id;\n\n// Store the rolls made during this session\nexport const recentRolls: any[] = [];\nexport const MAX_ROLLS_STORED = 20; // Store up to 20 recent rolls","// src/ts/utils/logger.ts\nimport { moduleId } from \"../constants\";\n\n/**\n * Utility for module logging with debug mode support\n */\nexport class ModuleLogger {\n  /**\n   * Check if debug mode is enabled\n   */\n  static debugLevel(): number {\n    return (game as Game).settings.get(moduleId, \"logLevel\") as number;\n  }\n\n  /**\n   * Log a debug message (only when debug mode is enabled)\n   */\n  static debug(message: string, ...args: any[]): void {\n    if (this.debugLevel() < 1) {\n      console.log(`${moduleId} | ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log info message (always shown)\n   */\n  static info(message: string, ...args: any[]): void {\n    if (this.debugLevel() < 2) {\n        console.log(`${moduleId} | ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log warning message (always shown)\n   */\n  static warn(message: string, ...args: any[]): void {\n    if (this.debugLevel() < 3) {\n      console.warn(`${moduleId} | ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log error message (always shown)\n   */\n  static error(message: string, ...args: any[]): void {\n    if (this.debugLevel() < 4) {\n        console.error(`${moduleId} | ${message}`, ...args);\n    }\n  }\n}","import { WebSocketManager } from \"./network/webSocketManager\";\n\n// WebSocket close codes\nexport enum WSCloseCodes {\n  Normal = 1000,\n  NoClientId = 4001,\n  NoAuth = 4002,\n  NoConnectedGuild = 4003,\n  InternalError = 4000,\n  DuplicateConnection = 4004,\n  ServerShutdown = 4005,\n}\n\n// Module-specific interfaces\nexport interface FoundryRestApi extends Game.ModuleData<any> {\n  socketManager: WebSocketManager | null;\n  api: FoundryRestApiAPI;\n}\n\nexport interface FoundryRestApiAPI {\n  getWebSocketManager: () => WebSocketManager | null;\n  search: (query: string, filter?: string) => Promise<any[]>;\n  getByUuid: (uuid: string) => Promise<any>;\n}\n\nexport interface WebSocketMessage {\n  type: string;\n  data: any;\n  sender?: string;\n  timestamp?: number;\n}\n\nexport interface ChatMessage {\n  content: string;\n  sender: string;\n  timestamp: number;\n}\n\nexport interface BackupFolder {\n  path: string;\n  name: string;\n}\n\n// Server route types\nexport declare namespace ServerRoutes {\n  export interface BackupResponse {\n    backups: string[];\n  }\n  \n  export interface APIDocsResponse {\n    message: string;\n    endpoints: {\n      path: string;\n      description: string;\n    }[];\n  }\n}\n\n// Make sure TypeScript sees this file as a module\nexport {};\n","import { WSCloseCodes } from \"../types\";\nimport { ModuleLogger } from \"../utils/logger\";\nimport { moduleId } from \"../constants\"; // Corrected import path\n\ntype MessageHandler = (data: any) => void;\n\nexport class WebSocketManager {\n  private url: string;\n  private token: string;\n  private socket: WebSocket | null = null;\n  private messageHandlers: Map<string, MessageHandler> = new Map();\n  private reconnectTimer: number | null = null;\n  private reconnectAttempts: number = 0;\n  private clientId: string;\n  private pingInterval: number | null = null;\n  private isConnecting: boolean = false;\n  private isPrimaryGM: boolean = false;\n  \n  // Singleton instance\n  private static instance: WebSocketManager | null = null;\n\n  constructor(url: string, token: string) {\n    this.url = url;\n    this.token = token;\n    this.clientId = `foundry-${(game as Game).user?.id || Math.random().toString(36).substring(2, 15)}`;\n    \n    // Determine if this is the primary GM (lowest user ID among full GMs with role 4)\n    this.isPrimaryGM = this.checkIfPrimaryGM();\n    \n    ModuleLogger.info(`Created WebSocketManager with clientId: ${this.clientId}, isPrimaryGM: ${this.isPrimaryGM}`);\n    \n    // Listen for user join/leave events to potentially take over as primary\n    if ((game as Game).user?.isGM && (game as Game).user?.role === 4) {\n      // When another user connects or disconnects, check if we need to become primary\n      Hooks.on(\"userConnected\", this.reevaluatePrimaryGM.bind(this));\n      Hooks.on(\"userDisconnected\", this.reevaluatePrimaryGM.bind(this));\n    }\n  }\n  \n  /**\n   * Factory method that ensures only one instance is created and only for GM users\n   * @param url The WebSocket server URL\n   * @param token The authorization token\n   * @returns WebSocketManager instance or null if not GM\n   */\n  public static getInstance(url: string, token: string): WebSocketManager | null {\n    // Only create an instance if the user is a full GM (role 4), not Assistant GM\n    if (!(game as Game).user?.isGM || (game as Game).user?.role !== 4) {\n      ModuleLogger.info(`WebSocketManager not created - user is not a full GM`);\n      return null;\n    }\n    \n    // Only create the instance once\n    if (!WebSocketManager.instance) {\n      ModuleLogger.info(`Creating new WebSocketManager instance`);\n      WebSocketManager.instance = new WebSocketManager(url, token);\n    }\n    \n    return WebSocketManager.instance;\n  }\n\n  /**\n   * Determines if this GM has the lowest user ID among all active GMs\n   */\n  private checkIfPrimaryGM(): boolean {\n    // Make sure current user is a full GM (role 4), not an Assistant GM\n    if (!(game as Game).user?.isGM || (game as Game).user?.role !== 4) return false;\n    \n    const currentUserId = (game as Game).user?.id;\n    // Only consider active users with role 4 (full GM), not Assistant GMs (role 3)\n    const activeGMs = (game as Game).users?.filter(u => u.role === 4 && u.active) || [];\n    \n    if (activeGMs.length === 0) return false;\n    \n    // Sort by user ID (alphanumeric)\n    const sortedGMs = [...activeGMs].sort((a, b) => (a.id || '').localeCompare(b.id || ''));\n    \n    // Check if current user has the lowest ID\n    const isPrimary = sortedGMs[0]?.id === currentUserId;\n    \n    ModuleLogger.info(`Primary GM check - Current user: ${currentUserId}, Primary GM: ${sortedGMs[0]?.id}, isPrimary: ${isPrimary}`);\n    \n    return isPrimary;\n  }\n  \n  /**\n   * Re-evaluate if this GM should be the primary when users connect/disconnect\n   */\n  private reevaluatePrimaryGM(): void {\n    const wasPrimary = this.isPrimaryGM;\n    this.isPrimaryGM = this.checkIfPrimaryGM();\n    \n    // If status changed, log it\n    if (wasPrimary !== this.isPrimaryGM) {\n      ModuleLogger.info(`Primary GM status changed: ${wasPrimary} -> ${this.isPrimaryGM}`);\n      \n      // If we just became primary, connect\n      if (this.isPrimaryGM && !this.isConnected()) {\n        ModuleLogger.info(`Taking over as primary GM, connecting WebSocket`);\n        this.connect();\n      }\n      \n      // If we're no longer primary, disconnect\n      if (!this.isPrimaryGM && this.isConnected()) {\n        ModuleLogger.info(`No longer primary GM, disconnecting WebSocket`);\n        this.disconnect();\n      }\n    }\n  }\n\n  connect(): void {\n    // Double-check that user is still a full GM (role 4) and is the primary GM before connecting\n    if (!(game as Game).user?.isGM || (game as Game).user?.role !== 4) {\n      ModuleLogger.info(`WebSocket connection aborted - user is not a full GM`);\n      return;\n    }\n    \n    if (!this.isPrimaryGM) {\n      ModuleLogger.info(`WebSocket connection aborted - user is not the primary GM`);\n      return;\n    }\n    \n    if (this.isConnecting) {\n      ModuleLogger.info(`Already attempting to connect`);\n      return;\n    }\n\n    if (this.socket && (this.socket.readyState === WebSocket.CONNECTING || this.socket.readyState === WebSocket.OPEN)) {\n      ModuleLogger.info(`WebSocket already connected or connecting`);\n      return;\n    }\n\n    this.isConnecting = true;\n\n    try {\n      // Build the WebSocket URL with query parameters\n      const wsUrl = new URL(this.url);\n      wsUrl.searchParams.set('id', this.clientId);\n      wsUrl.searchParams.set('token', this.token);\n      \n      ModuleLogger.info(`Connecting to WebSocket at ${wsUrl.toString()}`);\n      \n      // Create WebSocket and set up event handlers\n      this.socket = new WebSocket(wsUrl.toString());\n\n      // Add timeout for connection attempt\n      const connectionTimeout = window.setTimeout(() => {\n        if (this.socket && this.socket.readyState === WebSocket.CONNECTING) {\n          ModuleLogger.error(`Connection timed out`);\n          this.socket.close();\n          this.socket = null;\n          this.isConnecting = false;\n          this.scheduleReconnect();\n        }\n      }, 5000); // 5 second timeout\n\n      this.socket.addEventListener('open', (event) => {\n        window.clearTimeout(connectionTimeout);\n        this.onOpen(event);\n      });\n      \n      this.socket.addEventListener('close', (event) => {\n        window.clearTimeout(connectionTimeout);\n        this.onClose(event);\n      });\n      \n      this.socket.addEventListener('error', (event) => {\n        window.clearTimeout(connectionTimeout);\n        this.onError(event);\n      });\n      \n      this.socket.addEventListener('message', this.onMessage.bind(this));\n    } catch (error) {\n      ModuleLogger.error(`Error creating WebSocket:`, error);\n      this.isConnecting = false;\n      this.scheduleReconnect();\n    }\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      ModuleLogger.info(`Disconnecting WebSocket`);\n      this.socket.close(WSCloseCodes.Normal, \"Disconnecting\");\n      this.socket = null;\n    }\n    \n    if (this.reconnectTimer !== null) {\n      window.clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    \n    if (this.pingInterval !== null) {\n      window.clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n    \n    this.reconnectAttempts = 0;\n    this.isConnecting = false;\n  }\n\n  isConnected(): boolean {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n\n  send(data: any): boolean {\n    ModuleLogger.info(`Send called, readyState: ${this.socket?.readyState}`);\n    \n    // Ensure we're connected\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      try {\n        ModuleLogger.info(`Sending message:`, data);\n        this.socket.send(JSON.stringify(data));\n        return true;\n      } catch (error) {\n        ModuleLogger.error(`Error sending message:`, error);\n        return false;\n      }\n    } else {\n      ModuleLogger.warn(`WebSocket not ready, state: ${this.socket?.readyState}`);\n      return false;\n    }\n  }\n\n  onMessageType(type: string, handler: MessageHandler): void {\n    this.messageHandlers.set(type, handler);\n  }\n\n  private onOpen(_event: Event): void {\n    ModuleLogger.info(`WebSocket connected`);\n    this.isConnecting = false;\n    this.reconnectAttempts = 0;\n    \n    // Send an initial ping\n    this.send({ type: \"ping\" });\n    \n    // Start ping interval using the setting value\n    const pingIntervalSeconds = (game as Game).settings.get(moduleId, \"pingInterval\") as number;\n    const pingIntervalMs = pingIntervalSeconds * 1000;\n    ModuleLogger.info(`Starting application ping interval: ${pingIntervalSeconds} seconds`);\n    \n    // Clear any existing interval first\n    if (this.pingInterval !== null) {\n      window.clearInterval(this.pingInterval);\n    }\n    \n    this.pingInterval = window.setInterval(() => {\n      if (this.isConnected()) {\n        this.send({ type: \"ping\" });\n      }\n    }, pingIntervalMs);\n  }\n\n  private onClose(event: CloseEvent): void {\n    ModuleLogger.info(`WebSocket disconnected: ${event.code} - ${event.reason}`);\n    this.socket = null;\n    this.isConnecting = false;\n    \n    // Clear ping interval\n    if (this.pingInterval !== null) {\n      window.clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n    \n    // Don't reconnect if this was a normal closure or if not primary GM\n    if (event.code !== WSCloseCodes.Normal && this.isPrimaryGM) {\n      this.scheduleReconnect();\n    }\n  }\n\n  private onError(event: Event): void {\n    ModuleLogger.error(`WebSocket error:`, event);\n    this.isConnecting = false;\n  }\n\n  private async onMessage(event: MessageEvent): Promise<void> {\n    try {\n      const data = JSON.parse(event.data);\n      ModuleLogger.info(`Received message:`, data);\n      \n      if (data.type && this.messageHandlers.has(data.type)) {\n        ModuleLogger.info(`Handling message of type: ${data.type}`);\n        this.messageHandlers.get(data.type)!(data);\n      } else if (data.type) {\n        ModuleLogger.warn(`No handler for message type: ${data.type}`);\n      }\n    } catch (error) {\n      ModuleLogger.error(`Error processing message:`, error);\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (this.reconnectTimer !== null) {\n      return; // Already scheduled\n    }\n    \n    // Read settings for reconnection parameters\n    const maxAttempts = (game as Game).settings.get(moduleId, \"reconnectMaxAttempts\") as number;\n    const baseDelay = (game as Game).settings.get(moduleId, \"reconnectBaseDelay\") as number;\n    \n    this.reconnectAttempts++;\n    \n    if (this.reconnectAttempts > maxAttempts) {\n      ModuleLogger.error(`Maximum reconnection attempts (${maxAttempts}) reached`);\n      this.reconnectAttempts = 0; // Reset for future disconnections\n      return;\n    }\n    \n    // Calculate delay with exponential backoff (max 30 seconds)\n    const delay = Math.min(30000, baseDelay * Math.pow(2, this.reconnectAttempts - 1));\n    ModuleLogger.info(`Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${maxAttempts})`);\n    \n    this.reconnectTimer = window.setTimeout(() => {\n      this.reconnectTimer = null;\n      // Only attempt reconnect if still the primary GM\n      if (this.isPrimaryGM) {\n         ModuleLogger.info(`Attempting reconnect...`);\n         this.connect();\n      } else {\n         ModuleLogger.info(`Reconnect attempt aborted - no longer primary GM.`);\n         this.reconnectAttempts = 0; // Reset attempts if not primary\n      }\n    }, delay);\n  }\n}","export function parseFilterString(filterStr: string): Record<string, string> {\n    if (!filterStr.includes(':')) {\n      return { documentType: filterStr };\n    }\n    \n    const filters: Record<string, string> = {};\n    const parts = filterStr.split(',');\n    \n    for (const part of parts) {\n      if (part.includes(':')) {\n        const [key, value] = part.split(':');\n        if (key && value) {\n          filters[key.trim()] = value.trim();\n        }\n      }\n    }\n    \n    return filters;\n}\n\nexport function matchesAllFilters(result: any, filters: Record<string, string>): boolean {\n    for (const [key, value] of Object.entries(filters)) {\n      if (!value) continue;\n      \n      // Special handling for resultType (constructor name)\n      if (key === \"resultType\") {\n        const itemConstructorName = result.item?.constructor?.name;\n        if (!itemConstructorName || itemConstructorName.toLowerCase() !== value.toLowerCase()) {\n          return false;\n        }\n        continue;\n      }\n      \n      // Special handling for package (compendium) paths\n      if (key === \"package\" && result.item) {\n        const packageValue = result.item.package;\n        if (!packageValue) return false;\n        \n        // Check if the package matches or if it's a part of the full path\n        if (packageValue.toLowerCase() !== value.toLowerCase() && \n            !(`Compendium.${packageValue}`.toLowerCase() === value.toLowerCase())) {\n          return false;\n        }\n        continue;\n      }\n      \n      // Special handling for folder references\n      if (key === \"folder\" && result.item) {\n        const folderValue = result.item.folder;\n        \n        // No folder when one is required\n        if (!folderValue && value) return false;\n        \n        // Folder exists, check various formats:\n        if (folderValue) {\n          const folderIdMatch = typeof folderValue === 'object' ? folderValue.id : folderValue;\n          \n          // Accept any of these formats:\n          // - Just the ID: \"zmAZJmay9AxvRNqh\"\n          // - Full Folder UUID: \"Folder.zmAZJmay9AxvRNqh\"\n          // - Object format with ID\n          if (value === folderIdMatch || \n              value === `Folder.${folderIdMatch}` ||\n              `Folder.${value}` === folderIdMatch) {\n            continue; // Match found, continue to next filter\n          }\n          \n          // If we get here, folder doesn't match\n          return false;\n        }\n        \n        continue;\n      }\n      \n      // Standard property handling\n      let propertyValue;\n      if (!key.includes('.') && result.item && result.item[key] !== undefined) {\n        propertyValue = result.item[key];\n      } else {\n        const parts = key.split('.');\n        let current = result;\n        \n        for (const part of parts) {\n          if (current === undefined || current === null) {\n            propertyValue = undefined;\n            break;\n          }\n          current = current[part];\n        }\n        \n        propertyValue = current;\n      }\n      \n      // If the property is missing or doesn't match, filter it out\n      if (propertyValue === undefined || \n          (typeof propertyValue === 'string' &&\n           propertyValue.toLowerCase() !== value.toLowerCase())) {\n        return false;\n      }\n    }\n    \n    return true;\n}","/**\n * Utility functions for data serialization\n */\nimport { ModuleLogger } from \"./logger\";\n\n// Interface for collection-like objects in Foundry VTT\ninterface FoundryCollection<T> {\n    size: number;\n    contents: T[];\n    entries(): IterableIterator<[string, T]>;\n\n    // Other collection methods could be added here if needed\n}\n\n/**\n * Deep serialize an entity to ensure all properties are properly captured\n * @param entity The entity to serialize\n * @returns A fully serialized copy of the entity\n */\nexport function deepSerializeEntity(entity: any): any {\n    if (!entity) return null;\n    \n    try {\n        // Start with a standard serialization\n        let serialized = entity.toObject ? entity.toObject(true) : JSON.parse(JSON.stringify(entity));\n\n        // Some systems have getter properties that aren't properly serialized, especially in nested objects\n        // Manually handle key system paths that are commonly used\n        if (entity.system) {\n            // Handle attributes - commonly used in systems like dnd5e\n            if (entity.system.attributes) {\n                for (const [attrKey, attrValue] of Object.entries(entity.system.attributes)) {\n                    // Check if this attribute exists in serialized but is null when it shouldn't be\n                    if (\n                        serialized.system?.attributes?.[attrKey] === null && \n                        attrValue !== null\n                    ) {\n                        if (!serialized.system.attributes) serialized.system.attributes = {};\n                        serialized.system.attributes[attrKey] = JSON.parse(JSON.stringify(attrValue));\n                    }\n                    \n                    // Handle nested attributes (like hp, movement, etc)\n                    if (typeof attrValue === 'object' && attrValue !== null) {\n                        for (const [subKey, subValue] of Object.entries(attrValue)) {\n                            if (\n                                serialized.system?.attributes?.[attrKey]?.[subKey] === null && \n                                subValue !== null\n                            ) {\n                                if (!serialized.system.attributes[attrKey]) serialized.system.attributes[attrKey] = {};\n                                serialized.system.attributes[attrKey][subKey] = JSON.parse(JSON.stringify(subValue));\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Handle traits, senses, and other commonly used properties\n            ['traits', 'abilities', 'skills', 'resources'].forEach(propKey => {\n                if (entity.system[propKey]) {\n                    for (const [key, value] of Object.entries(entity.system[propKey])) {\n                        if (\n                            serialized.system?.[propKey]?.[key] === null && \n                            value !== null\n                        ) {\n                            if (!serialized.system[propKey]) serialized.system[propKey] = {};\n                            serialized.system[propKey][key] = JSON.parse(JSON.stringify(value));\n                        }\n                        \n                        // Handle nested properties\n                        if (typeof value === 'object' && value !== null) {\n                            for (const [subKey, subValue] of Object.entries(value)) {\n                                if (\n                                    serialized.system?.[propKey]?.[key]?.[subKey] === null && \n                                    subValue !== null\n                                ) {\n                                    if (!serialized.system[propKey][key]) serialized.system[propKey][key] = {};\n                                    serialized.system[propKey][key][subKey] = JSON.parse(JSON.stringify(subValue));\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n\n        // Special handling for embedded collections \n        if (entity.items && entity.items.size > 0 && Array.isArray(serialized.items)) {\n            // Ensure items are properly serialized\n            try {\n                // Type assertion to help TypeScript understand the collection structure\n                const itemCollection = entity.items as FoundryCollection<any>;\n                \n                // Use contents array if available, as a safer alternative to entries()\n                if (Array.isArray(itemCollection.contents)) {\n                    for (let i = 0; i < itemCollection.contents.length; i++) {\n                        if (i < serialized.items.length) {\n                            // Deep serialize each item\n                            serialized.items[i] = deepSerializeEntity(itemCollection.contents[i]);\n                        }\n                    }\n                } \n                // Fallback to entries() if needed\n                else if (typeof itemCollection.entries === 'function') {\n                    const itemEntries = Array.from(itemCollection.entries());\n                    for (let i = 0; i < itemEntries.length; i++) {\n                        const [_, item] = itemEntries[i];\n                        if (i < serialized.items.length) {\n                            serialized.items[i] = deepSerializeEntity(item);\n                        }\n                    }\n                }\n            } catch (err) {\n                ModuleLogger.warn('Failed to process entity.items collection:', err);\n            }\n        }\n        \n        // Handle effects collection\n        if (entity.effects && entity.effects.size > 0 && Array.isArray(serialized.effects)) {\n            try {\n                // Type assertion to help TypeScript understand the collection structure\n                const effectCollection = entity.effects as FoundryCollection<any>;\n                \n                // Use contents array if available, as a safer alternative to entries()\n                if (Array.isArray(effectCollection.contents)) {\n                    for (let i = 0; i < effectCollection.contents.length; i++) {\n                        if (i < serialized.effects.length) {\n                            // Deep serialize each effect\n                            serialized.effects[i] = deepSerializeEntity(effectCollection.contents[i]);\n                        }\n                    }\n                }\n                // Fallback to entries() if needed\n                else if (typeof effectCollection.entries === 'function') {\n                    const effectEntries = Array.from(effectCollection.entries());\n                    for (let i = 0; i < effectEntries.length; i++) {\n                        const [_, effect] = effectEntries[i];\n                        if (i < serialized.effects.length) {\n                            serialized.effects[i] = deepSerializeEntity(effect);\n                        }\n                    }\n                }\n            } catch (err) {\n                ModuleLogger.warn('Failed to process entity.effects collection:', err);\n            }\n        }\n        \n        return serialized;\n    } catch (error) {\n        ModuleLogger.error(`Error deep serializing entity:`, error);\n        // Fallback to basic serialization in case of errors\n        return entity.toObject ? entity.toObject() : entity;\n    }\n}","import { moduleId, recentRolls } from \"../constants\";\nimport { FoundryRestApi } from \"../types\";\nimport { ModuleLogger } from \"../utils/logger\";\nimport { WebSocketManager } from \"./webSocketManager\";\nimport { parseFilterString, matchesAllFilters } from \"../utils/search\";\nimport { deepSerializeEntity } from \"../utils/serialization\";\n\nexport function initializeWebSocket() {\n    // Get settings\n    const wsRelayUrl = (game as Game).settings.get(moduleId, \"wsRelayUrl\") as string;\n    const apiKey = (game as Game).settings.get(moduleId, \"apiKey\") as string;\n    const module = (game as Game).modules.get(moduleId) as FoundryRestApi;\n    \n    if (!wsRelayUrl) {\n      ModuleLogger.error(`Local relay server URL is empty. Please configure it in module settings.`);\n      return;\n    }\n    \n    ModuleLogger.info(`Initializing WebSocket connection to local relay server: ${wsRelayUrl}`);\n    \n    try {\n        // Create and connect the WebSocket manager - only if it doesn't exist already\n        if (!module.socketManager) {\n            module.socketManager = WebSocketManager.getInstance(wsRelayUrl, apiKey);\n            // Only attempt to connect if we got a valid instance (meaning this GM is the primary GM)\n            if (module.socketManager) {\n                module.socketManager.connect();\n            }\n        } else {\n            ModuleLogger.info(`WebSocket manager already exists, not creating a new one`);\n        }\n        \n        // If we don't have a valid socket manager, exit early\n        if (!module.socketManager) {\n            ModuleLogger.warn(`No WebSocket manager available, skipping message handler setup`);\n            return;\n        }\n        \n        // Register message handlers\n        const socketManager = module.socketManager; // Store reference to prevent null checks on every line\n        \n        socketManager.onMessageType(\"ping\", () => {\n            ModuleLogger.info(`Received ping, sending pong`);\n            socketManager.send({ type: \"pong\" });\n        });\n    \n        socketManager.onMessageType(\"pong\", () => {\n            ModuleLogger.info(`Received pong`);\n        });\n        \n        // Handle search requests\n        socketManager.onMessageType(\"perform-search\", async (data) => {\n            ModuleLogger.info(`Received search request:`, data);\n            \n            try {\n            if (!window.QuickInsert) {\n                ModuleLogger.error(`QuickInsert not available`);\n                socketManager.send({\n                type: \"search-results\",\n                requestId: data.requestId,\n                query: data.query,\n                error: \"QuickInsert not available\",\n                results: []\n                });\n                return;\n            }\n            \n            if (!window.QuickInsert.hasIndex) {\n                ModuleLogger.info(`QuickInsert index not ready, forcing index creation`);\n                try {\n                window.QuickInsert.forceIndex();\n                await new Promise(resolve => setTimeout(resolve, 500));\n                } catch (error) {\n                ModuleLogger.error(`Failed to force QuickInsert index:`, error);\n                socketManager.send({\n                    type: \"search-results\",\n                    requestId: data.requestId,\n                    query: data.query,\n                    error: \"QuickInsert index not ready\",\n                    results: []\n                });\n                return;\n                }\n            }\n    \n            let filterFunc = null;\n            if (data.filter) {\n                const filters = typeof data.filter === 'string' ? \n                parseFilterString(data.filter) : data.filter;\n    \n                filterFunc = (result: any) => {\n                return matchesAllFilters(result, filters);\n                };\n            }\n            \n            const filteredResults = await window.QuickInsert.search(data.query, filterFunc, 200);\n            ModuleLogger.info(`Search returned ${filteredResults.length} results`);\n            \n            socketManager.send({\n                type: \"search-results\",\n                requestId: data.requestId,\n                query: data.query,\n                filter: data.filter,\n                results: filteredResults.map(result => {\n                const item = result.item;\n                \n                return {\n                    documentType: item.documentType,\n                    folder: item.folder,\n                    id: item.id,\n                    name: item.name,\n                    package: item.package,\n                    packageName: item.packageName,\n                    subType: item.subType,\n                    uuid: item.uuid,\n                    icon: item.icon,\n                    journalLink: item.journalLink,\n                    tagline: item.tagline || \"\",\n                    formattedMatch: result.formattedMatch || \"\",\n                    resultType: item.constructor?.name\n                };\n                })\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error performing search:`, error);\n            socketManager.send({\n                type: \"search-results\",\n                requestId: data.requestId,\n                query: data.query,\n                error: (error as Error).message,\n                results: []\n            });\n            }\n        });\n        \n        // Handle entity requests\n        socketManager.onMessageType(\"get-entity\", async (data) => {\n            ModuleLogger.info(`Received entity request:`, data);\n            \n            try {\n                let entity;\n                let entityData = [];\n                let entityUUID = data.uuid;\n                if (data.selected) {\n                    const controlledTokens = canvas?.tokens?.controlled;\n                    if (controlledTokens) {\n                        for (let token of controlledTokens) {\n                            if (data.actor) {\n                                entity = token.actor;\n                            } else {\n                                entity = token.document;\n                            }\n                            if (entity) {\n                                entityUUID = entity.uuid;\n                                // Use custom deep serialization\n                                entityData.push(deepSerializeEntity(entity));\n                            }\n                        }\n                    }\n                } else {\n                    entity = await fromUuid(data.uuid);\n                    // Use custom deep serialization\n                    entityData = entity ? deepSerializeEntity(entity) : null;\n                }\n                \n                if (!entityData) {\n                    ModuleLogger.error(`Entity not found: ${data.uuid}`);\n                    socketManager.send({\n                    type: \"entity-data\",\n                    requestId: data.requestId,\n                    uuid: data.uuid,\n                    error: \"Entity not found\",\n                    data: null\n                    });\n                    return;\n                }\n                \n                ModuleLogger.info(`Sending entity data for: ${data.uuid}`, entityData);\n                \n                socketManager.send({\n                    type: \"entity-data\",\n                    requestId: data.requestId,\n                    uuid: entityUUID,\n                    data: entityData\n                });\n            } catch (error) {\n                ModuleLogger.error(`Error getting entity:`, error);\n                socketManager.send({\n                    type: \"entity-data\",\n                    requestId: data.requestId,\n                    uuid: data.uuid,\n                    error: (error as Error).message,\n                    data: null\n            });\n            }\n        });\n    \n        // Handle structure request\n        socketManager.onMessageType(\"get-structure\", async (data) => {\n            ModuleLogger.info(`Received structure request`);\n            \n            try {\n            // Get all folders\n            const folders = Object.entries((game as Game).folders?.contents || []).map(([_, folder]) => {\n                return {\n                id: folder.id,\n                name: folder.name,\n                type: folder.type,\n                parent: folder.parent?.id,\n                path: folder.uuid,\n                sorting: (folder as any).sort,\n                sortingMode: (folder as any).sortingMode\n                };\n            });\n            \n            // Get all compendiums\n            const compendiums = (game as Game).packs.contents.map(pack => {\n                return {\n                id: pack.collection,\n                name: pack.metadata.label,\n                path: `Compendium.${pack.collection}`,\n                entity: pack.documentName,\n                package: pack.metadata.package,\n                packageType: pack.metadata.type,\n                system: pack.metadata.system\n                };\n            });\n            \n            socketManager.send({\n                type: \"structure-data\",\n                requestId: data.requestId,\n                folders,\n                compendiums\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error getting structure:`, error);\n            socketManager.send({\n                type: \"structure-data\",\n                requestId: data.requestId,\n                error: (error as Error).message,\n                folders: [],\n                compendiums: []\n            });\n            }\n        });\n        \n        // Handle contents request\n        socketManager.onMessageType(\"get-contents\", async (data) => {\n            ModuleLogger.info(`Received contents request for path: ${data.path}`);\n            \n            try {\n            let contents = [];\n            \n            if (data.path.startsWith(\"Compendium.\")) {\n                // Handle compendium path\n                const pack = (game as Game).packs.get(data.path.replace(\"Compendium.\", \"\"));\n                if (!pack) {\n                throw new Error(`Compendium not found: ${data.path}`);\n                }\n                \n                // Get the index if not already loaded\n                const index = await pack.getIndex();\n                \n                // Return entries from the index\n                contents = index.contents.map(entry => {\n                return {\n                    uuid: `${pack.collection}.${entry._id}`,\n                    id: entry._id,\n                    name: entry.name,\n                    img: 'img' in entry ? entry.img : null,\n                    type: 'type' in entry ? entry.type : null\n                };\n                });\n            } else {\n                // Handle folder path\n                // Extract folder ID from path like \"Folder.abcdef12345\"\n                const folderMatch = data.path.match(/Folder\\.([a-zA-Z0-9]+)/);\n                if (!folderMatch) {\n                throw new Error(`Invalid folder path: ${data.path}`);\n                }\n                \n                const folderId = folderMatch[1];\n                const folder = (game as Game).folders?.get(folderId);\n                \n                if (!folder) {\n                throw new Error(`Folder not found: ${data.path}`);\n                }\n                \n                // Get entities in folder\n                contents = folder.contents.map(entity => {\n                return {\n                    uuid: entity.uuid,\n                    id: entity.id,\n                    name: entity.name,\n                    img: 'img' in entity ? entity.img : null,\n                    type: entity.documentName\n                };\n                });\n            }\n            \n            socketManager.send({\n                type: \"contents-data\",\n                requestId: data.requestId,\n                path: data.path,\n                entities: contents\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error getting contents:`, error);\n            socketManager.send({\n                type: \"contents-data\",\n                requestId: data.requestId,\n                path: data.path,\n                error: (error as Error).message,\n                entities: []\n            });\n            }\n        });\n        \n        // Handle entity creation\n        socketManager.onMessageType(\"create-entity\", async (data) => {\n            ModuleLogger.info(`Received create entity request for type: ${data.entityType}`);\n            \n            try {\n            // Get the document class for the entity type\n            const DocumentClass = getDocumentClass(data.entityType);\n            if (!DocumentClass) {\n                throw new Error(`Invalid entity type: ${data.entityType}`);\n            }\n            \n            // Prepare creation data\n            const createData = {\n                ...data.data,\n                folder: data.folder || null\n            };\n            \n            // Create the entity\n            const entity = await DocumentClass.create(createData);\n            \n            if (!entity) {\n                throw new Error(\"Failed to create entity\");\n            }\n            \n            socketManager.send({\n                type: \"entity-created\",\n                requestId: data.requestId,\n                uuid: entity.uuid,\n                entity: entity.toObject()\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error creating entity:`, error);\n            socketManager.send({\n                type: \"entity-created\",\n                requestId: data.requestId,\n                error: (error as Error).message,\n                message: \"Failed to create entity\"\n            });\n            }\n        });\n        \n        // Handle entity update\n        socketManager.onMessageType(\"update-entity\", async (data) => {\n            ModuleLogger.info(`Received update entity request for UUID: ${data.uuid}`);\n            \n            try {\n            // Get the entities\n            let entities = [];\n            if (data.uuid) {\n                entities.push(await fromUuid(data.uuid));\n            } else if (data.selected) {\n                const controlledTokens = canvas?.tokens?.controlled;\n                if (controlledTokens) {\n                    for (let token of controlledTokens) {\n                        if (data.actor) {\n                            entities.push(token.actor);\n                        } else {\n                            entities.push(token.document);\n                        }\n                    }\n                }\n            }\n            \n            if (entities.length === 0) {\n                throw new Error(`Entity not found: ${data.uuid}`);\n            }\n            \n            // Update the entities\n            for (let entity of entities) {\n                await entity?.update(data.updateData);\n            }\n            \n            // Get the updated entities\n            let updatedEntities = [];\n            for (let entity of entities) {\n                updatedEntities.push(await fromUuid((entity as any).uuid));\n            }\n            \n            socketManager.send({\n                type: \"entity-updated\",\n                requestId: data.requestId,\n                uuid: data.uuid,\n                entity: updatedEntities.map(e => e?.toObject())\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error updating entity:`, error);\n            socketManager.send({\n                type: \"entity-updated\",\n                requestId: data.requestId,\n                uuid: data.uuid,\n                error: (error as Error).message,\n                message: \"Failed to update entity\"\n            });\n            }\n        });\n        \n        // Handle entity deletion\n        socketManager.onMessageType(\"delete-entity\", async (data) => {\n            ModuleLogger.info(`Received delete entity request for UUID: ${data.uuid}`);\n            \n            try {\n            // Get the entities\n            let entities = [];\n            if (data.uuid) {\n                entities.push(await fromUuid(data.uuid));\n            } else if (data.selected) {\n                const controlledTokens = canvas?.tokens?.controlled;\n                if (controlledTokens) {\n                    for (let token of controlledTokens) {\n                        if (data.actor) {\n                            entities.push(token.actor);\n                        } else {\n                            entities.push(token.document);\n                        }\n                    }\n                }\n            }\n            \n            if (!entities || entities.length === 0) {\n                throw new Error(`Entity not found: ${data.uuid}`);\n            }\n            \n            // Delete the entities\n            for (let entity of entities) {\n                await entity?.delete();\n            }\n            \n            socketManager.send({\n                type: \"entity-deleted\",\n                requestId: data.requestId,\n                uuid: data.uuid,\n                success: true\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error deleting entity:`, error);\n            socketManager.send({\n                type: \"entity-deleted\",\n                requestId: data.requestId,\n                uuid: data.uuid,\n                error: (error as Error).message,\n                message: \"Failed to delete entity\"\n            });\n            }\n        });\n    \n        // Handle roll data request (get list of rolls)\n        socketManager.onMessageType(\"get-rolls\", async (data) => {\n            ModuleLogger.info(`Received request for roll data`);\n            \n            socketManager.send({\n            type: \"rolls-data\",\n            requestId: data.requestId,\n            data: recentRolls.slice(0, data.limit || 20)\n            });\n        });\n    \n        // Handle last roll request\n        socketManager.onMessageType(\"get-last-roll\", (data) => {\n            ModuleLogger.info(`Received request for last roll data`);\n            \n            socketManager.send({\n            type: \"last-roll-data\",\n            requestId: data.requestId,\n            data: recentRolls.length > 0 ? recentRolls[0] : null\n            });\n        });\n    \n        // Handle roll request\n        socketManager.onMessageType(\"perform-roll\", async (data) => {\n            try {\n            const { formula, itemUuid, flavor, createChatMessage, speaker, target, whisper, requestId } = data;\n            \n            let rollResult;\n            let speakerData = {};\n            let rollMode = whisper && whisper.length > 0 ? CONST.DICE_ROLL_MODES.PRIVATE : CONST.DICE_ROLL_MODES.PUBLIC;\n            \n            // Process speaker if provided\n            if (speaker) {\n                try {\n                // Check if it's a token UUID or actor UUID\n                const speakerEntity = await fromUuid(speaker);\n                \n                if (speakerEntity) {\n                    if (speakerEntity instanceof TokenDocument) {\n                    // It's a token\n                    speakerData = {\n                        token: speakerEntity?.id,\n                        actor: speakerEntity?.actor?.id,\n                        scene: speakerEntity?.parent?.id,\n                        alias: speakerEntity?.name || speakerEntity?.actor?.name\n                    };\n                    } else if (speakerEntity instanceof Actor) {\n                    // It's an actor - try to find a token that represents it on the active scene\n                    const activeScene = (game as Game).scenes?.active;\n                    if (activeScene) {\n                        const tokens = activeScene.tokens?.filter(t => t.actor?.id === speakerEntity.id);\n                        if (tokens && tokens.length > 0) {\n                        // Use the first token found\n                        const token = tokens[0];\n                        speakerData = {\n                            token: token.id,\n                            actor: speakerEntity.id,\n                            scene: activeScene.id,\n                            alias: token.name || speakerEntity.name\n                        };\n                        } else {\n                        // No token found, just use actor\n                        speakerData = {\n                            actor: speakerEntity.id,\n                            alias: speakerEntity.name\n                        };\n                        }\n                    }\n                    }\n                }\n                } catch (err) {\n                ModuleLogger.warn(`Failed to process speaker: ${err}`);\n                }\n            }\n            \n            // Process the roll\n            if (itemUuid) {\n                try {\n                // Get the item document\n                const document = await fromUuid(itemUuid);\n                if (!document) {\n                    throw new Error(`Item with UUID ${itemUuid} not found`);\n                }\n                \n                // Cast to an Item with any to access system-specific properties\n                const item = document as any;\n                \n                ModuleLogger.info(`Creating chat message for item: ${(item as any).name}`);\n                \n                let messageId;\n                let targetAcquired = false;\n                let targetToken = null;\n                \n                // Process target if provided\n                if (target) {\n                    try {\n                    const targetDocument = await fromUuid(target);\n                    \n                    if (targetDocument) {\n                        if (targetDocument instanceof TokenDocument) {\n                        // It's a token\n                        targetToken = targetDocument;\n                        targetAcquired = true;\n                        ModuleLogger.info(`Target token acquired: ${targetDocument.name}`);\n                        } else if (targetDocument instanceof Actor) {\n                        // It's an actor - try to find a token that represents it on the active scene\n                        const activeScene = (game as Game).scenes?.active;\n                        if (activeScene) {\n                            const tokens = activeScene.tokens?.filter(t => t.actor?.id === targetDocument.id);\n                            if (tokens && tokens.length > 0) {\n                            // Use the first token found\n                            targetToken = tokens[0];\n                            targetAcquired = true;\n                            ModuleLogger.info(`Target token acquired from actor: ${tokens[0].name}`);\n                            }\n                        }\n                        }\n                        \n                        // If we found a token, set it as the target\n                        if (targetAcquired && targetToken) {\n                        // For D&D 5e and similar systems, we need to target the token on the canvas\n                        // This will ensure that systems like Midi-QOL can properly apply effects\n                        if (canvas && canvas.ready) {\n                            // Clear current targets first\n                            if (canvas.tokens) {\n                            (game as Game).user?.targets.forEach(t => t.setTarget(false, { user: (game as Game).user, releaseOthers: false, groupSelection: false }));\n                            (game as Game).user?.targets.clear();\n                            \n                            // Get the actual token object from the canvas\n                            if (targetToken.id) {  // Check that the ID is not null or undefined\n                                const targetObject = canvas.tokens.get(targetToken.id);\n                                if (targetObject) {\n                                // Set as target\n                                targetObject.setTarget(true, { user: (game as Game).user, releaseOthers: true, groupSelection: false });\n                                ModuleLogger.info(`Token targeted on canvas: ${targetObject.name}`);\n                                }\n                            }\n                            }\n                        }\n                        }\n                    }\n                    } catch (err) {\n                    ModuleLogger.warn(`Failed to process target: ${err}`);\n                    }\n                }\n                \n                // Different systems have different methods for displaying items in chat\n                if ((item as any).system?.actionType) {\n                    // This is a D&D 5e item with an action type - use specific handling for Midi-QOL\n                    ModuleLogger.info(`Using D&D 5e item with action type: ${(item as any).system.actionType}`);\n                    \n                    // For D&D 5e with Midi-QOL, we need to use the item's use method\n                    if (((item as Record<string, any>).system as Record<string, any>)?.actionType) {\n                    // Create options for item use\n                    const useOptions: any = {\n                        configureDialog: false,\n                        createMessage: true,\n                        skipDialog: true,\n                        fastForward: true,\n                        consume: false, // Don't consume limited uses by default\n                        speaker: speakerData,\n                        target: targetToken\n                    };\n                    \n                    // If target was acquired, add it\n                    if (targetAcquired && targetToken) {\n                        useOptions.target = targetToken;\n                    }\n                    \n                    // Set up automatic dialog handling before using the item\n                    const originalRenderDialog = Dialog.prototype.render;\n                    \n                    // Override Dialog.prototype.render to add auto-clicking behavior\n                    Dialog.prototype.render = function(...args) {\n                        const result = originalRenderDialog.apply(this, args);\n                        \n                        // After the dialog renders, click the default or first button\n                        setTimeout(() => {\n                        if (this.element && this.element.length) {\n                            const defaultButton = this.element.find('.dialog-button.default');\n                            if (defaultButton.length) {\n                            ModuleLogger.info(`Auto-clicking default button in rendered dialog`);\n                            defaultButton.trigger('click');\n                            } else {\n                            const firstButton = this.element.find('.dialog-button').first();\n                            if (firstButton.length) {\n                                ModuleLogger.info(`Auto-clicking first button in rendered dialog`);\n                                firstButton.trigger('click');\n                            }\n                            }\n                        }\n                        }, 100);\n                        \n                        return result;\n                    };\n                    \n                    try {\n                        // Use the item which should trigger Midi-QOL if installed\n                        ModuleLogger.info(`Using item with dialog auto-click enabled: ${(item as any).name}`);\n                        const useResult = await (((item as Record<string, any>).use) as Function)(useOptions);\n                        messageId = useResult?.id || useResult; // Handle different return types\n                        \n                        ModuleLogger.info(`Item used with use() method, should trigger Midi-QOL: ${(item as any).name}`);\n                    } finally {\n                        Dialog.prototype.render = originalRenderDialog;\n                        \n                        ModuleLogger.info(`Restored original dialog methods after item use`);\n                    }\n                    } else if ((item as any).displayCard && typeof (item as any).displayCard === 'function') {\n                    // Fallback to displayCard if use() not available\n                    const cardResult = await (item as any).displayCard({\n                        createMessage: true,\n                        speaker: speakerData,\n                        ...(targetAcquired ? { target: targetToken } : {})\n                    });\n                    messageId = cardResult?.id;\n                    }\n                } else if (typeof (item as any).toChat === 'function') {\n                    // Some systems use toChat()\n                    const chatOptions = targetAcquired ? { target: targetToken } : {};\n                    const chatResult = await (item as any).toChat(chatOptions);\n                    messageId = chatResult?.id;\n                } else if (typeof (item as any).displayCard === 'function') {\n                    // DnD5e uses displayCard()\n                    // Use type assertion to ensure TypeScript knows displayCard is a function\n                    const displayCard = (item as any).displayCard as (options: any) => Promise<any>;\n                    const cardResult = await displayCard({\n                    createMessage: true,\n                    speaker: speakerData,\n                    // If target acquired, add it to the options\n                    ...(targetAcquired ? { target: targetToken } : {})\n                    });\n                    messageId = cardResult?.id;\n                } else {\n                    // Fallback: Create a simple chat message with item details\n                    const chatData = {\n                    user: (game as Game).user?.id,\n                    speaker: speakerData,\n                    content: `\n                        <div class=\"item-card\">\n                        <div class=\"item-name\">${(item as any).name}</div>\n                        <div class=\"item-image\"><img src=\"${(item as any).img}\" width=\"50\" height=\"50\"/></div>\n                        <div class=\"item-description\">${(item as any).system?.description?.value || \"\"}</div>\n                        ${targetAcquired ? `<div class=\"item-target\">Target: ${targetToken?.name}</div>` : \"\"}\n                        </div>\n                    `,\n                    type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                    flavor: `Item: ${(item as any).name}${targetAcquired ? ` (Target: ${targetToken?.name})` : \"\"}`\n                    };\n                    \n                    const message = await ChatMessage.create(chatData);\n                    messageId = message?.id;\n                }\n                \n                // Format the result\n                rollResult = {\n                    id: `item_display_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,\n                    chatMessageCreated: true,\n                    itemDisplayed: {\n                    uuid: (item as any).uuid,\n                    name: (item as any).name,\n                    type: (item as any).type,\n                    img: (item as any).img\n                    },\n                    target: targetAcquired ? {\n                    uuid: targetToken?.uuid,\n                    name: targetToken?.name\n                    } : null,\n                    messageId: messageId\n                };\n                \n                ModuleLogger.info(`Item chat message created with ID: ${messageId}`);\n                } catch (err) {\n                ModuleLogger.error(`Error displaying item in chat: ${err}`);\n                socketManager.send({\n                    type: \"roll-result\",\n                    requestId: requestId,\n                    success: false,\n                    error: `Failed to display item in chat: ${(err as Error).message}`\n                });\n                return;\n                }\n            } else {\n                // Roll from formula\n                try {\n                // Create the Roll instance\n                const roll = new Roll(formula);\n                \n                // Evaluate the roll\n                await roll.evaluate();\n                \n                // Create chat message if requested\n                if (createChatMessage) {\n                    await roll.toMessage({\n                    speaker: speakerData,\n                    flavor: flavor || \"\",\n                    rollMode,\n                    whisper: whisper || []\n                    });\n                }\n                \n                // Format the roll result\n                rollResult = {\n                    id: `manual_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,\n                    chatMessageCreated: !!createChatMessage,\n                    roll: {\n                    formula: formula,\n                    total: roll.total,\n                    isCritical: roll.terms.some(term => (term as DiceTerm).results?.some(result => result.result === (roll.terms[0] as DiceTerm).faces)),\n                    isFumble: roll.terms.some(term => (term as DiceTerm).results?.some(result => result.result === 1)),\n                    dice: roll.dice.map(d => ({\n                    faces: d.faces,\n                    results: d.results.map(r => ({\n                    result: r.result,\n                    active: r.active\n                    }))\n                    })),\n                    timestamp: Date.now()\n                    }\n                };\n                } catch (err) {\n                ModuleLogger.error(`Error rolling formula: ${err}`);\n                socketManager.send({\n                    type: \"roll-result\",\n                    requestId: requestId,\n                    success: false,\n                    error: `Failed to roll formula: ${(err as Error).message}`\n                });\n                return;\n                }\n            }\n            \n            // Send the result back\n            socketManager.send({\n                type: \"roll-result\",\n                requestId: requestId,\n                success: true,\n                data: rollResult\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error in roll handler: ${error}`);\n            socketManager.send({\n                type: \"roll-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message || \"Unknown error occurred during roll\"\n            });\n            }\n        });\n    \n        // Handle actor (or entity) sheet HTML request\n        socketManager.onMessageType(\"get-sheet-html\", async (data) => {\n            ModuleLogger.info(`Received sheet HTML request for UUID: ${data.uuid}`);\n            \n            try {\n            let actor: Actor | TokenDocument | null = null;\n            if (data.uuid) {\n                // Get the actor from its UUID\n                actor = await fromUuid(data.uuid) as Actor;\n            } else if (data.selected) {\n                // Get the controlled tokens\n                const controlledTokens = canvas?.tokens?.controlled;\n                if (controlledTokens && controlledTokens.length > 0) {\n                    if (data.actor) {\n                        actor = controlledTokens[0].actor;\n                    } else {\n                        actor = controlledTokens[0].document;\n                    }\n                }\n            }\n            if (!actor) {\n                ModuleLogger.error(`Entity not found for UUID: ${data.uuid}`);\n                socketManager.send({\n                type: \"actor-sheet-html-response\",\n                requestId: data.requestId,\n                data: { error: \"Entity not found\", uuid: data.uuid }\n                });\n                return;\n            }\n            \n            // Create a temporary sheet to render\n            const sheet = actor.sheet?.render(true) as ActorSheet;\n            \n            // Wait for the sheet to render\n            setTimeout(async () => {\n                try {\n                // Get the HTML content\n                if (!sheet.element || !sheet.element[0]) {\n                    throw new Error(\"Failed to render actor sheet\");\n                }\n                \n                let html = sheet.element[0].outerHTML;\n                \n                // Get the associated CSS - much more comprehensive approach\n                let css = '';\n                \n                // Get the sheet's appId for later comparisons\n                const sheetAppId = String(sheet.appId);\n                \n                // 1. Get CSS from style elements with data-appid matching the sheet\n                const appStyles = document.querySelectorAll('style[data-appid]');\n                appStyles.forEach(style => {\n                    const styleAppId = (style as HTMLElement).dataset.appid;\n                    if (styleAppId === sheetAppId) {\n                    css += style.textContent + '\\n';\n                    }\n                });\n                \n                // 2. Get global system styles that might apply to this sheet\n                const systemStyles = document.querySelectorAll(`style[id^=\"system-${(actor as any).type}\"]`);\n                systemStyles.forEach(style => {\n                    css += style.textContent + '\\n';\n                });\n                \n                // 3. Extract all classes and IDs from the HTML to capture all relevant styles\n                const tempDiv = document.createElement('div');\n                tempDiv.innerHTML = html;\n                \n                // Create sets to avoid duplicates\n                const classNames = new Set<string>();\n                const ids = new Set<string>();\n                \n                // Function to extract classes and IDs from an element and its children\n                function extractClassesAndIds(element: Element) {\n                    // Get classes\n                    if (element.classList && element.classList.length) {\n                    element.classList.forEach(className => classNames.add(className));\n                    }\n                    \n                    // Get ID\n                    if (element.id) {\n                    ids.add(element.id);\n                    }\n                    \n                    // Process children recursively\n                    for (let i = 0; i < element.children.length; i++) {\n                    extractClassesAndIds(element.children[i]);\n                    }\n                }\n                \n                // Extract classes and IDs from all elements\n                extractClassesAndIds(tempDiv);\n                \n                // Convert sets to arrays\n                const uniqueClassNames = Array.from(classNames);\n                const uniqueIds = Array.from(ids);\n                \n                ModuleLogger.debug(`Extracted ${uniqueClassNames.length} unique classes and ${uniqueIds.length} unique IDs`);\n                \n                // 4. Collect all stylesheets in the document\n                const allStyles = document.querySelectorAll('style');\n                const allLinks = document.querySelectorAll('link[rel=\"stylesheet\"]');\n                \n                // Process inline styles\n                allStyles.forEach(style => {\n                    // Skip if we already added this style sheet (avoid duplicates)\n                    if (style.dataset.appid && style.dataset.appid === sheetAppId) {\n                    return; // Already added above\n                    }\n                    \n                    const styleContent = style.textContent || '';\n                    \n                    // Check if this style contains any of our classes or IDs\n                    const isRelevant = uniqueClassNames.some(className => \n                    styleContent.includes(`.${className}`)) || \n                    uniqueIds.some(id => styleContent.includes(`#${id}`)) ||\n                    // Common selectors that might apply\n                    styleContent.includes('.window-app') || \n                    styleContent.includes('.sheet') || \n                    styleContent.includes('.actor-sheet') ||\n                    styleContent.includes(`.${(actor as any).type}-sheet`);\n                    \n                    if (isRelevant) {\n                    ModuleLogger.debug(`Adding relevant inline style`);\n                    css += styleContent + '\\n';\n                    }\n                });\n                \n                // 5. Process external stylesheets\n                const stylesheetPromises = Array.from(allLinks).map(async (link) => {\n                    try {\n                    const href = link.getAttribute('href');\n                    if (!href) return '';\n                    \n                    // Skip foundry-specific stylesheets that we'll handle separately\n                    if (href.includes('fonts.googleapis.com')) return '';\n                    \n                    ModuleLogger.debug(`Fetching external CSS from: ${href}`);\n                    const fullUrl = href.startsWith('http') ? href : \n                                    href.startsWith('/') ? `${window.location.origin}${href}` : \n                                    `${window.location.origin}/${href}`;\n                    \n                    const response = await fetch(fullUrl);\n                    if (!response.ok) {\n                        ModuleLogger.warn(`Failed to fetch CSS: ${fullUrl}, status: ${response.status}`);\n                        return '';\n                    }\n                    \n                    const styleContent = await response.text();\n                    return styleContent;\n                    } catch (e) {\n                    ModuleLogger.warn(`Failed to fetch external CSS: ${e}`);\n                    return '';\n                    }\n                });\n                \n                // 6. Important: Add foundry core styles\n                const baseUrl = window.location.origin;\n                ModuleLogger.debug(`Base URL for fetching CSS: ${baseUrl}`);\n                \n                // Try different path patterns that might work with Foundry\n                const coreStylesheets = [\n                    // Try various likely paths for foundry core styles\n                    `${baseUrl}/css/style.css`,\n                    `${baseUrl}/styles/style.css`,\n                    `${baseUrl}/styles/foundry.css`,\n                    `${baseUrl}/ui/sheets.css`,\n                    // Try with /game path prefix (common in some Foundry setups)\n                    `${baseUrl}/game/styles/foundry.css`,\n                    `${baseUrl}/game/ui/sheets.css`,\n                    // System-specific styles\n                    `${baseUrl}/systems/${(game as Game).system.id}/system.css`,\n                    `${baseUrl}/systems/${(game as Game).system.id}/styles/system.css`,\n                    // Try with /game path prefix for system styles\n                    `${baseUrl}/game/systems/${(game as Game).system.id}/system.css`,\n                    `${baseUrl}/game/systems/${(game as Game).system.id}/styles/system.css`\n                ];\n                \n                // Add more debugging to identify the correct paths\n                ModuleLogger.debug(`All stylesheet links in document:`, \n                    Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'))\n                    .map(link => link.getAttribute('href'))\n                    .filter(Boolean)\n                );\n                \n                // Extract potential stylesheet paths from existing links\n                const existingCSSPaths = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'))\n                    .map(link => link.getAttribute('href'))\n                    .filter((href): href is string => \n                    href !== null && \n                    !href.includes('fonts.googleapis.com') && \n                    !href.includes('//'));\n                \n                // Add these paths to our core stylesheets\n                coreStylesheets.push(...existingCSSPaths);\n                \n                // Debug current document styles to see what's actually loaded\n                ModuleLogger.debug(`All style elements in document:`, \n                    document.querySelectorAll('style').length\n                );\n                \n                const corePromises = coreStylesheets.map(async (path) => {\n                    try {\n                    ModuleLogger.debug(`Fetching core CSS from: ${path}`);\n                    const response = await fetch(path);\n                    if (!response.ok) {\n                        ModuleLogger.warn(`Failed to fetch CSS: ${path}, status: ${response.status}`);\n                        return '';\n                    }\n                    \n                    // If successful, log it clearly\n                    ModuleLogger.info(`Successfully loaded CSS from: ${path}`);\n                    return await response.text();\n                    } catch (e) {\n                    ModuleLogger.warn(`Failed to fetch core CSS: ${e}`);\n                    return '';\n                    }\n                });\n                \n                // Wait for all external CSS to be fetched\n                const allPromises = [...stylesheetPromises, ...corePromises];\n                const externalStyles = await Promise.all(allPromises);\n                externalStyles.forEach(style => {\n                    css += style + '\\n';\n                });\n                \n                // 7. Add fallback styles if needed\n                if (css.length < 100) {\n                    ModuleLogger.warn(`CSS fetch failed or returned minimal content. Adding fallback styles.`);\n                    css += `\n        /* Fallback styles for actor sheet */\n        .window-app {\n            font-family: \"Signika\", sans-serif;\n            background: #f0f0e0;\n            border-radius: 5px;\n            box-shadow: 0 0 20px #000;\n            color: #191813;\n        }\n        .window-content {\n            background: rgba(255, 255, 240, 0.9);\n            padding: 8px;\n            overflow-y: auto;\n            background: url(${window.location.origin}/ui/parchment.jpg) repeat;\n        }\n        input, select, textarea {\n            border: 1px solid #7a7971;\n            background: rgba(255, 255, 255, 0.8);\n        }\n        button {\n            background: rgba(0, 0, 0, 0.1);\n            border: 1px solid #7a7971;\n            border-radius: 3px;\n            cursor: pointer;\n        }\n        .profile-img {\n            border: none;\n            max-width: 100%;\n            max-height: 220px;\n        }\n        `;\n                }\n                \n                // Log the CSS collection results\n                ModuleLogger.debug(`Collected CSS: ${css.length} bytes`);\n                \n                // Before sending the HTML, fix asset URLs\n                html = html.replace(/src=\"([^\"]+)\"/g, (match, src) => {\n                    if (src.startsWith('http')) return match;\n                    if (src.startsWith('/')) return `src=\"${window.location.origin}${src}\"`;\n                    return `src=\"${window.location.origin}/${src}\"`;\n                });\n    \n                // Also fix background images in styles\n                css = css.replace(/url\\(['\"]?([^'\")]+)['\"]?\\)/g, (match, url) => {\n                    if (url.startsWith('http') || url.startsWith('data:')) return match;\n                    if (url.startsWith('/')) return `url('${window.location.origin}${url}')`;\n                    return `url('${window.location.origin}/${url}')`;\n                });\n    \n                // Close the temporary sheet\n                sheet.close();\n                \n                // Send the HTML and CSS back\n                socketManager.send({\n                    type: \"actor-sheet-html-response\",\n                    requestId: data.requestId,\n                    data: { html, css, uuid: data.uuid }\n                });\n    \n                // Add confirmation log\n                ModuleLogger.debug(`Sent actor sheet HTML response with requestId: ${data.requestId}`);\n                ModuleLogger.debug(`HTML length: ${html.length}, CSS length: ${css.length}`);\n                } catch (renderError) {\n                ModuleLogger.error(`Error capturing actor sheet HTML:`, renderError);\n                socketManager.send({\n                    type: \"actor-sheet-html-response\",\n                    requestId: data.requestId,\n                    data: { error: \"Failed to capture actor sheet HTML\", uuid: data.uuid }\n                });\n                \n                // Make sure to close the sheet if it was created\n                if (sheet && typeof sheet.close === 'function') {\n                    sheet.close();\n                }\n                }\n            }, 500); // Small delay to ensure rendering is complete\n            \n            } catch (error) {\n            ModuleLogger.error(`Error rendering actor sheet:`, error);\n            socketManager.send({\n                type: \"actor-sheet-html-response\",\n                requestId: data.requestId,\n                data: { error: \"Failed to render actor sheet\", uuid: data.uuid }\n            });\n            }\n        });\n    \n        // Handle get macros request\n        socketManager.onMessageType(\"get-macros\", async (data) => {\n            ModuleLogger.info(`Received request for macros`);\n            \n            try {\n            // Get all macros the current user has access to\n            const macros = (game as Game).macros?.contents.map(macro => {\n                return {\n                uuid: macro.uuid,\n                id: macro.id,\n                name: macro.name,\n                type: (macro as any).type || (macro as any).data?.type || \"unknown\",\n                author: (macro as any).author?.name || \"unknown\",\n                command: (macro as any).command || \"\",\n                img: (macro as any).img,\n                scope: (macro as any).scope,\n                canExecute: (macro as any).canExecute\n                };\n            }) || [];\n    \n            socketManager.send({\n                type: \"macros-list\",\n                requestId: data.requestId,\n                macros\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error getting macros list:`, error);\n            socketManager.send({\n                type: \"macros-list\",\n                requestId: data.requestId,\n                error: (error as Error).message,\n                macros: []\n            });\n            }\n        });\n\n        // Handle get hotbar request\n        socketManager.onMessageType(\"get-hotbar\", async (data) => {\n            ModuleLogger.info(`Received request for hotbar data`);\n            \n            try {\n                // Simpler approach - get current hotbar page and user data\n                const currentPage = ((ui as any).hotbar?.page) || 1;\n                const hotbarData: any[] = [];\n                \n                ModuleLogger.info(`Current hotbar page: ${currentPage}`);\n                \n                // Get user data more safely\n                const userData = (game as Game).user?.data || {};\n                ModuleLogger.info(`User data keys: ${Object.keys(userData)}`);\n                \n                // Try multiple ways to access hotbar data\n                const hotbarFlags = (userData as any).flags?.hotbar || {};\n                const directHotbar = (userData as any).hotbar || {};\n                \n                ModuleLogger.info(`Hotbar flags keys: ${Object.keys(hotbarFlags)}`);\n                ModuleLogger.info(`Direct hotbar keys: ${Object.keys(directHotbar)}`);\n                \n                for (let i = 1; i <= 10; i++) {\n                    const slot = ((currentPage - 1) * 10) + i;\n                    const macroId = hotbarFlags[slot] || directHotbar[slot];\n                    \n                    ModuleLogger.info(`Slot ${i} (index ${slot}): macroId = ${macroId}`);\n                    \n                    if (macroId) {\n                        const macro = (game as Game).macros?.get(macroId);\n                        if (macro) {\n                            hotbarData.push({\n                                slot: i,\n                                uuid: macro.uuid,\n                                id: macro.id,\n                                name: macro.name,\n                                type: (macro as any).type || \"unknown\",\n                                img: (macro as any).img,\n                                command: (macro as any).command || \"\",\n                                canExecute: (macro as any).canExecute\n                            });\n                        } else {\n                            ModuleLogger.info(`Macro with ID ${macroId} not found`);\n                            hotbarData.push({\n                                slot: i,\n                                macroId: macroId,\n                                notFound: true\n                            });\n                        }\n                    } else {\n                        hotbarData.push({\n                            slot: i,\n                            empty: true\n                        });\n                    }\n                }\n                \n                socketManager.send({\n                    type: \"hotbar-data\",\n                    requestId: data.requestId,\n                    currentPage: currentPage,\n                    hotbar: hotbarData\n                });\n            } catch (error) {\n                ModuleLogger.error(`Error getting hotbar data:`, error);\n                socketManager.send({\n                    type: \"hotbar-data\",\n                    requestId: data.requestId,\n                    error: (error as Error).message,\n                    hotbar: []\n                });\n            }\n        });\n    \n        // Handle execute macro request\n        socketManager.onMessageType(\"execute-macro\", async (data) => {\n            ModuleLogger.info(`Received request to execute macro: ${data.uuid}`);\n            \n            try {\n            if (!data.uuid) {\n                throw new Error(\"Macro UUID is required\");\n            }\n            \n            // Get the macro by UUID\n            const macro = await fromUuid(data.uuid) as Macro;\n            if (!macro) {\n                throw new Error(`Macro not found with UUID: ${data.uuid}`);\n            }\n            \n            // Check if it's actually a macro\n            if (!(macro instanceof CONFIG.Macro.documentClass)) {\n                throw new Error(`Entity with UUID ${data.uuid} is not a macro`);\n            }\n            \n            // Check if the macro can be executed\n            if (!macro.canExecute) {\n                throw new Error(`Macro '${macro.name}' cannot be executed by the current user`);\n            }\n\n            const args = data.args || {};\n            \n            // Execute the macro with args defined in the scope\n            let result;\n            if (typeof args === \"object\") {\n                // Execute with args available as a variable\n                result = await macro.execute({ args } as any);\n            } else {\n                // Fallback for non-object args\n                result = await macro.execute();\n            }\n            \n            // Return success\n            socketManager.send({\n                type: \"macro-execution-result\",\n                requestId: data.requestId,\n                uuid: data.uuid,\n                success: true,\n                result: typeof result === 'object' ? result : { value: result }\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error executing macro:`, error);\n            socketManager.send({\n                type: \"macro-execution-result\",\n                requestId: data.requestId,\n                uuid: data.uuid || \"\",\n                success: false,\n                error: (error as Error).message\n            });\n            }\n        });\n    \n        // Handle get encounters request\n        socketManager.onMessageType(\"get-encounters\", async (data) => {\n            ModuleLogger.info(`Received request for encounters`);\n            \n            try {\n            // Get all combats (encounters) in the world\n            const encounters = (game as Game).combats?.contents.map(combat => {\n                return {\n                id: combat.id,\n                name: combat.name,\n                round: combat.round,\n                turn: combat.turn,\n                current: combat.id === (game as Game).combat?.id,\n                combatants: combat.combatants.contents.map(c => ({\n                    id: c.id,\n                    name: c.name,\n                    tokenUuid: c.token?.uuid,\n                    actorUuid: c.actor?.uuid,\n                    img: c.img,\n                    initiative: c.initiative,\n                    hidden: c.hidden,\n                    defeated: c.isDefeated\n                }))\n                };\n            }) || [];\n    \n            socketManager.send({\n                type: \"encounters-list\",\n                requestId: data.requestId,\n                encounters\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error getting encounters list:`, error);\n            socketManager.send({\n                type: \"encounters-list\",\n                requestId: data.requestId,\n                error: (error as Error).message,\n                encounters: []\n            });\n            }\n        });\n    \n        // Handle start encounter request\n        socketManager.onMessageType(\"start-encounter\", async (data) => {\n            ModuleLogger.info(`Received request to start encounter with options:`, data);\n            \n            try {\n            // Create a new combat encounter\n            const combat = await Combat.create({ name: data.name || \"New Encounter\" });\n            \n            if (combat) {\n                await combat.startCombat();\n                // Add the specified tokens if any were provided\n                if (data.tokenUuids && data.tokenUuids.length > 0) {\n                const tokensData = [];\n                \n                for (const uuid of data.tokenUuids) {\n                    try {\n                    const token = await fromUuid(uuid);\n                    if (token) {\n                        tokensData.push({\n                        tokenId: token.id ?? '',\n                        sceneId: token.parent.id\n                        });\n                    }\n                    } catch (err) {\n                    ModuleLogger.warn(`Failed to add token ${uuid} to combat:`, err);\n                    }\n                }\n                \n                if (tokensData.length > 0) {\n                    await combat.createEmbeddedDocuments(\"Combatant\", tokensData);\n                }\n                }\n    \n                let addedTokenIds = new Set();\n    \n                // Add player combatants if specified\n                if (data.startWithPlayers) {\n                // Get the current viewed scene\n                const currentScene = (game as Game).scenes?.viewed;\n                \n                if (currentScene) {\n                    // Get all tokens on the scene that have player actors\n                    const playerTokens = currentScene.tokens?.filter(token => {\n                    // Check if token has an actor and the actor is a player character\n                    return !!token.actor && token.actor.hasPlayerOwner;\n                    }) ?? [];\n                    \n                    // Create combatants from these tokens\n                    const tokenData = playerTokens.map(token => {\n                    addedTokenIds.add(token.id);\n                    return {\n                    tokenId: token.id,\n                    sceneId: currentScene.id\n                    };\n                    });\n                    \n                    if (tokenData.length > 0) {\n                    await combat.createEmbeddedDocuments(\"Combatant\", tokenData);\n                    }\n                }\n                }\n    \n                // Add selected tokens if specified, but only if they weren't already added\n                if (data.startWithSelected) {\n                const selectedTokens = canvas?.tokens?.controlled\n                    .filter(token => !addedTokenIds.has(token.id))\n                    .map(token => {\n                    return {\n                    tokenId: token.id,\n                    sceneId: token.scene.id\n                    };\n                    }) ?? [];\n                \n                if (selectedTokens.length > 0) {\n                    await combat.createEmbeddedDocuments(\"Combatant\", selectedTokens);\n                }\n                } \n                \n                // Roll initiative for all npc combatants\n                if (data.rollNPC) {\n                await combat.rollNPC();\n                }\n    \n                // Roll initiative for all combatants\n                if (data.rollAll) {\n                await combat.rollAll();\n                }\n                \n                // Activate this combat\n                await combat.activate();\n                \n                socketManager.send({\n                type: \"encounter-started\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                encounter: {\n                    id: combat.id,\n                    name: combat.name,\n                    round: combat.round,\n                    turn: combat.turn,\n                    combatants: combat.combatants.contents.map(c => ({\n                    id: c.id,\n                    name: c.name,\n                    tokenUuid: c.token?.uuid,\n                    actorUuid: c.actor?.uuid,\n                    img: c.img,\n                    initiative: c.initiative,\n                    hidden: c.hidden,\n                    defeated: c.isDefeated\n                    }))\n                }\n                });\n            } else {\n                throw new Error(\"Failed to create encounter\");\n            }\n            } catch (error) {\n            ModuleLogger.error(`Error starting encounter:`, error);\n            socketManager.send({\n                type: \"encounter-started\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n    \n        // Handle next turn request\n        socketManager.onMessageType(\"encounter-next-turn\", async (data) => {\n            ModuleLogger.info(`Received request for next turn in encounter: ${data.encounterId || 'active'}`);\n            \n            try {\n            const combat = data.encounterId ? (game as Game).combats?.get(data.encounterId) : (game as Game).combat;\n            \n            if (!combat) {\n                throw new Error(data.encounterId ? \n                `Encounter with ID ${data.encounterId} not found` : \n                \"No active encounter\");\n            }\n            \n            await combat.nextTurn();\n            \n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                action: \"nextTurn\",\n                currentTurn: combat.turn,\n                currentRound: combat.round,\n                actorTurn: combat.combatant?.actor?.uuid,\n                tokenTurn: combat.combatant?.token?.uuid,\n                encounter: {\n                id: combat.id,\n                name: combat.name,\n                round: combat.round,\n                turn: combat.turn\n                }\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error advancing to next turn:`, error);\n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n    \n        // Handle next round request\n        socketManager.onMessageType(\"encounter-next-round\", async (data) => {\n            ModuleLogger.info(`Received request for next round in encounter: ${data.encounterId || 'active'}`);\n            \n            try {\n            const combat = data.encounterId ? (game as Game).combats?.get(data.encounterId) : (game as Game).combat;\n            \n            if (!combat) {\n                throw new Error(data.encounterId ? \n                `Encounter with ID ${data.encounterId} not found` : \n                \"No active encounter\");\n            }\n            \n            await combat.nextRound();\n            \n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                action: \"nextRound\",\n                currentTurn: combat.turn,\n                currentRound: combat.round,\n                actorTurn: combat.combatant?.actor?.uuid,\n                tokenTurn: combat.combatant?.token?.uuid,\n                encounter: {\n                id: combat.id,\n                name: combat.name,\n                round: combat.round,\n                turn: combat.turn\n                }\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error advancing to next round:`, error);\n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n    \n        // Handle previous turn request\n        socketManager.onMessageType(\"encounter-previous-turn\", async (data) => {\n            ModuleLogger.info(`Received request for previous turn in encounter: ${data.encounterId || 'active'}`);\n            \n            try {\n            const combat = data.encounterId ? (game as Game).combats?.get(data.encounterId) : (game as Game).combat;\n            \n            if (!combat) {\n                throw new Error(data.encounterId ? \n                `Encounter with ID ${data.encounterId} not found` : \n                \"No active encounter\");\n            }\n            \n            await combat.previousTurn();\n            \n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                action: \"previousTurn\",\n                currentTurn: combat.turn,\n                currentRound: combat.round,\n                actorTurn: combat.combatant?.actor?.uuid,\n                tokenTurn: combat.combatant?.token?.uuid,\n                encounter: {\n                id: combat.id,\n                name: combat.name,\n                round: combat.round,\n                turn: combat.turn\n                }\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error going back to previous turn:`, error);\n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n    \n        // Handle previous round request\n        socketManager.onMessageType(\"encounter-previous-round\", async (data) => {\n            ModuleLogger.info(`Received request for previous round in encounter: ${data.encounterId || 'active'}`);\n            \n            try {\n            const combat = data.encounterId ? (game as Game).combats?.get(data.encounterId) : (game as Game).combat;\n            \n            if (!combat) {\n                throw new Error(data.encounterId ? \n                `Encounter with ID ${data.encounterId} not found` : \n                \"No active encounter\");\n            }\n            \n            await combat.previousRound();\n            \n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                action: \"previousRound\",\n                currentTurn: combat.turn,\n                currentRound: combat.round,\n                actorTurn: combat.combatant?.actor?.uuid,\n                tokenTurn: combat.combatant?.token?.uuid,\n                encounter: {\n                id: combat.id,\n                name: combat.name,\n                round: combat.round,\n                turn: combat.turn\n                }\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error going back to previous round:`, error);\n            socketManager.send({\n                type: \"encounter-navigation\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n    \n        // Handle end encounter request\n        socketManager.onMessageType(\"end-encounter\", async (data) => {\n            ModuleLogger.info(`Received request to end encounter: ${data.encounterId}`);\n            \n            try {\n            let encounterId = data.encounterId;\n            if (!encounterId) {\n                encounterId = (game as Game).combat?.id;\n            }\n            \n            const combat = (game as Game).combats?.get(encounterId);\n            \n            if (!combat) {\n                throw new Error(`No encounter not found`);\n            }\n            \n            await combat.delete();\n            \n            socketManager.send({\n                type: \"encounter-ended\",\n                requestId: data.requestId,\n                encounterId: encounterId,\n                message: \"Encounter successfully ended\"\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error ending encounter:`, error);\n            socketManager.send({\n                type: \"encounter-ended\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n\n        // Add these handlers after the other encounter-related handlers\n\n        // Handle add-to-encounter request\n        socketManager.onMessageType(\"add-to-encounter\", async (data) => {\n            ModuleLogger.info(`Received add-to-encounter request for encounter: ${data.encounterId}`);\n            \n            try {\n            // Get the combat\n            const combat = data.encounterId ? \n                (game as Game).combats?.get(data.encounterId) : \n                (game as Game).combat;\n            \n            if (!combat) {\n                throw new Error(data.encounterId ? \n                `Encounter with ID ${data.encounterId} not found` : \n                \"No active encounter\");\n            }\n            \n            const addedEntities: string[] = [];\n            const failedEntities = [];\n            \n            // Process UUIDs to add\n            if (data.uuids && Array.isArray(data.uuids)) {\n                for (const uuid of data.uuids) {\n                try {\n                    // Get the entity from UUID\n                    const entity = await fromUuid(uuid);\n                    \n                    if (!entity) {\n                    failedEntities.push({ uuid, reason: \"Entity not found\" });\n                    continue;\n                    }\n                    \n                    // Handle depending on entity type - token or actor\n                    if (entity.documentName === \"Token\") {\n                    const token = entity;\n                    const combatantData = {\n                        tokenId: token.id,\n                        sceneId: token.parent?.id\n                    };\n                    \n                    await combat.createEmbeddedDocuments(\"Combatant\", [combatantData]);\n                    addedEntities.push(uuid);\n                    } else if (entity.documentName === \"Actor\") {\n                    // For actors, we need a token representation\n                    // Here we check if actor has a token on the current scene\n                    const scene = (game as Game).scenes?.viewed;\n                    if (scene) {\n                        const tokenForActor = scene.tokens?.find(t => t.actor?.id === entity.id);\n                        if (tokenForActor) {\n                        const combatantData = {\n                            tokenId: tokenForActor.id,\n                            sceneId: scene.id\n                        };\n                        \n                        await combat.createEmbeddedDocuments(\"Combatant\", [combatantData]);\n                        addedEntities.push(uuid);\n                        } else {\n                        failedEntities.push({ uuid, reason: \"No token found for this actor in the current scene\" });\n                        }\n                    } else {\n                        failedEntities.push({ uuid, reason: \"No active scene\" });\n                    }\n                    } else {\n                    failedEntities.push({ uuid, reason: \"Entity must be a Token or Actor\" });\n                    }\n                } catch (err) {\n                    failedEntities.push({ uuid, reason: (err as Error).message });\n                }\n                }\n            }\n            \n            // If selected is true, add selected tokens\n            if (data.selected === true) {\n                const selectedTokens = canvas?.tokens?.controlled || [];\n                \n                for (const token of selectedTokens) {\n                try {\n                    if (!combat.combatants.find(c => c.token?.id === token.id && c.combat?.scene?.id === token.scene.id)) {\n                        const combatantData = {\n                        tokenId: token.id,\n                        sceneId: token.scene.id\n                        };\n                        \n                        await combat.createEmbeddedDocuments(\"Combatant\", [combatantData]);\n                        addedEntities.push(token.document.uuid);\n                    }\n                } catch (err) {\n                    failedEntities.push({ uuid: token.document.uuid, reason: (err as Error).message });\n                }\n                }\n            }\n            \n            // Roll initiative for new combatants if requested\n            if (data.rollInitiative === true && addedEntities.length > 0) {\n                combat.rollAll();\n            }\n            \n            socketManager.send({\n                type: \"add-to-encounter-result\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                added: addedEntities,\n                failed: failedEntities\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error adding to encounter:`, error);\n            socketManager.send({\n                type: \"add-to-encounter-result\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n        \n        // Handle remove-from-encounter request\n        socketManager.onMessageType(\"remove-from-encounter\", async (data) => {\n            ModuleLogger.info(`Received remove-from-encounter request for encounter: ${data.encounterId}`);\n            \n            try {\n            // Get the combat\n            const combat = data.encounterId ? \n                (game as Game).combats?.get(data.encounterId) : \n                (game as Game).combat;\n            \n            if (!combat) {\n                throw new Error(data.encounterId ? \n                `Encounter with ID ${data.encounterId} not found` : \n                \"No active encounter\");\n            }\n            \n            const removedEntities = [];\n            const failedEntities = [];\n            const combatantIdsToRemove = [];\n            \n            // Process UUIDs to remove\n            if (data.uuids && Array.isArray(data.uuids)) {\n                for (const uuid of data.uuids) {\n                try {\n                    // Find combatant(s) related to this UUID\n                    const entity = await fromUuid(uuid);\n                    \n                    if (!entity) {\n                    failedEntities.push({ uuid, reason: \"Entity not found\" });\n                    continue;\n                    }\n                    \n                    let foundCombatant = false;\n                    \n                    if (entity.documentName === \"Token\") {\n                    // Find combatant by token ID\n                    const combatant = combat.combatants.find(c => \n                        c.token?.id === entity.id && c.combat?.scene?.id === entity.parent?.id\n                    );\n                    \n                    if (combatant) {\n                        combatantIdsToRemove.push(combatant.id);\n                        foundCombatant = true;\n                    }\n                    } else if (entity.documentName === \"Actor\") {\n                    // Find all combatants with this actor\n                    const combatants = combat.combatants.filter(c => c.actor?.id === entity.id);\n                    \n                    if (combatants.length > 0) {\n                        combatantIdsToRemove.push(...combatants.map(c => c.id));\n                        foundCombatant = true;\n                    }\n                    }\n                    \n                    if (foundCombatant) {\n                    removedEntities.push(uuid);\n                    } else {\n                    failedEntities.push({ uuid, reason: \"No combatant found for this entity\" });\n                    }\n                } catch (err) {\n                    failedEntities.push({ uuid, reason: (err as Error).message });\n                }\n                }\n            }\n            \n            // If selected is true, remove selected tokens\n            if (data.selected === true) {\n                const selectedTokens = canvas?.tokens?.controlled || [];\n                \n                for (const token of selectedTokens) {\n                const combatant = combat.combatants.find(c => \n                    (c as any).tokenId === token.id && (c as any).sceneId === token.scene.id\n                );\n                \n                if (combatant) {\n                    combatantIdsToRemove.push(combatant.id);\n                    removedEntities.push(token.document.uuid);\n                }\n                }\n            }\n            \n            // Remove the combatants, filtering out any null IDs\n            if (combatantIdsToRemove.length > 0) {\n                const validIds = combatantIdsToRemove.filter((id): id is string => id !== null);\n                if (validIds.length > 0) {\n                    await combat.deleteEmbeddedDocuments(\"Combatant\", validIds);\n                }\n            }\n            \n            socketManager.send({\n                type: \"remove-from-encounter-result\",\n                requestId: data.requestId,\n                encounterId: combat.id,\n                removed: removedEntities,\n                failed: failedEntities\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error removing from encounter:`, error);\n            socketManager.send({\n                type: \"remove-from-encounter-result\",\n                requestId: data.requestId,\n                error: (error as Error).message\n            });\n            }\n        });\n        \n        // Handle kill request (mark token/actor as defeated)\n        socketManager.onMessageType(\"kill-entity\", async (data) => {\n            ModuleLogger.info(`Received kill request for UUID: ${data.uuid}`);\n            \n            try {\n            const entities = [];\n\n            if (data.uuid) {\n                const entity = await fromUuid(data.uuid);\n                if (entity) {\n                entities.push(entity);\n                } else {\n                throw new Error(`Entity not found: ${data.uuid}`);\n                }\n            } else if (data.selected) {\n                const controlledTokens = canvas?.tokens?.controlled || [];\n                for (const token of controlledTokens) {\n                if (token.document) {\n                    entities.push(token.document);\n                }\n                }\n            }\n\n            if (entities.length === 0) {\n                throw new Error(\"No entities found to mark as defeated\");\n            }\n\n            const results = [];\n\n            for (const entity of entities) {\n                let success = false;\n                let message = \"\";\n\n                // Handle different entity types\n                if (entity.documentName === \"Token\") {\n                const token = entity;\n                const actor = (token as any).actor;\n\n                if (!actor) {\n                    throw new Error(\"Token has no associated actor\");\n                }\n\n                // 1. Mark as defeated in combat if in encounter\n                const combat = (game as Game).combat;\n                if (combat) {\n                    const combatant = combat.combatants.find(c => \n                    c.token?.id === token.id && c.token?.parent?.id === token.parent?.id\n                    );\n                    \n                    if (combatant) {\n                    await combatant.update({ defeated: true });\n                    ModuleLogger.info(`Marked token as defeated in combat`);\n                    }\n                }\n\n                // 2. Reduce HP to 0 - try different possible HP paths for different systems\n                try {\n                    if (hasProperty(actor, \"system.attributes.hp\")) {\n                    await actor.update({ \"system.attributes.hp.value\": 0 });\n                    } \n                    else if (hasProperty(actor, \"system.health\")) {\n                    await actor.update({ \"system.health.value\": 0 });\n                    }\n                    else if (hasProperty(actor, \"system.hp\")) {\n                    await actor.update({ \"system.hp.value\": 0 });\n                    }\n                    else if (hasProperty(actor, \"data.attributes.hp\")) {\n                    await actor.update({ \"data.attributes.hp.value\": 0 });\n                    }\n                    ModuleLogger.info(`Set actor HP to 0`);\n                } catch (err) {\n                    ModuleLogger.warn(`Could not set HP to 0: ${err}`);\n                }\n\n                // 3. Add dead status effect to token\n                try {\n                    const deadEffect = CONFIG.statusEffects?.find(e => \n                    e.id === \"dead\" || e.id === \"unconscious\" || e.id === \"defeated\"\n                    );\n                    \n                    if (deadEffect) {\n                    await (token as any).toggleActiveEffect(deadEffect);\n                    ModuleLogger.info(`Added ${deadEffect.id} status effect to token`);\n                    } else {\n                    ModuleLogger.warn(`No dead status effect found`);\n                    }\n                } catch (err) {\n                    ModuleLogger.warn(`Could not apply status effect: ${err}`);\n                }\n\n                success = true;\n                message = \"Token marked as defeated, HP set to 0, and dead effect applied\";\n                } else if (entity.documentName === \"Actor\") {\n                const actor = entity;\n                let tokensUpdated = 0;\n\n                // 1. Find all tokens for this actor across visible scenes and update them\n                const scenes = (game as Game).scenes;\n                if (scenes?.viewed) {\n                    const tokens = scenes.viewed.tokens.filter(t => t.actor?.id === actor.id);\n                    \n                    for (const token of tokens) {\n                    try {\n                        const deadEffect = CONFIG.statusEffects?.find(e => \n                        e.id === \"dead\" || e.id === \"unconscious\" || e.id === \"defeated\"\n                        );\n                        \n                        if (deadEffect) {\n                        await (token as any).toggleActiveEffect(deadEffect);\n                        tokensUpdated++;\n                        }\n                    } catch (err) {\n                        ModuleLogger.warn(`Could not apply status effect to token: ${err}`);\n                    }\n                    }\n                }\n\n                // 2. Mark all instances in combat as defeated\n                const combat = (game as Game).combat;\n                if (combat) {\n                    const combatants = combat.combatants.filter(c => c.actor?.id === actor.id);\n                    \n                    if (combatants.length > 0) {\n                    await Promise.all(combatants.map(c => c.update({ defeated: true })));\n                    ModuleLogger.info(`Marked ${combatants.length} combatants as defeated`);\n                    }\n                }\n\n                // 3. Reduce HP to 0 - try different possible HP paths for different systems\n                try {\n                    if (hasProperty(actor, \"system.attributes.hp\")) {\n                    await actor.update({ \"system.attributes.hp.value\": 0 });\n                    } \n                    else if (hasProperty(actor, \"system.health\")) {\n                    await actor.update({ \"system.health.value\": 0 });\n                    }\n                    else if (hasProperty(actor, \"system.hp\")) {\n                    await actor.update({ \"system.hp.value\": 0 });\n                    }\n                    else if (hasProperty(actor, \"data.attributes.hp\")) {\n                    await actor.update({ \"data.attributes.hp.value\": 0 });\n                    }\n                    ModuleLogger.info(`Set actor HP to 0`);\n                } catch (err) {\n                    ModuleLogger.warn(`Could not set HP to 0: ${err}`);\n                }\n\n                success = true;\n                message = `Actor marked as defeated, HP set to 0, and dead effect applied to ${tokensUpdated} tokens`;\n                } else {\n                throw new Error(`Cannot mark entity type ${entity.documentName} as defeated`);\n                }\n\n                results.push({\n                uuid: (entity as any).uuid,\n                success,\n                message\n                });\n            }\n\n            socketManager.send({\n                type: \"kill-entity-result\",\n                requestId: data.requestId,\n                results\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error marking entities as defeated:`, error);\n            socketManager.send({\n                type: \"kill-entity-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n            }\n        });\n        \n        // Handle decrease attribute request\n        socketManager.onMessageType(\"decrease-attribute\", async (data) => {\n            ModuleLogger.info(`Received decrease attribute request for attribute: ${data.attribute}, amount: ${data.amount}`);\n            \n            try {\n            if (!data.uuid && !data.selected) {\n                throw new Error(\"UUID or selected is required\");\n            }\n            if (!data.attribute) throw new Error(\"Attribute path is required\");\n            if (typeof data.amount !== 'number') throw new Error(\"Amount must be a number\");\n            \n            const entities = [];\n            if (data.selected) {\n                const controlledTokens = canvas?.tokens?.controlled || [];\n                for (const token of controlledTokens) {\n                if (token.actor) {\n                    entities.push(token.actor);\n                }\n                }\n            } else if (data.uuid) {\n                const entity = await fromUuid(data.uuid);\n                if (entity) {\n                entities.push(entity);\n                }\n            }\n\n            if (entities.length === 0) {\n                throw new Error(\"No entities found to modify\");\n            }\n\n            const results = [];\n            for (const entity of entities) {\n                // Get current value\n                const currentValue = getProperty(entity, data.attribute);\n                if (typeof currentValue !== 'number') {\n                throw new Error(`Attribute ${data.attribute} is not a number, found: ${typeof currentValue}`);\n                }\n\n                // Calculate new value\n                const newValue = currentValue - data.amount;\n\n                // Prepare update data\n                const updateData: { [key: string]: number } = {};\n                updateData[data.attribute] = newValue;\n\n                // Apply the update\n                await entity.update(updateData);\n\n                results.push({\n                uuid: (entity as any).uuid,\n                attribute: data.attribute,\n                oldValue: currentValue,\n                newValue: newValue\n                });\n            }\n\n            socketManager.send({\n                type: \"modify-attribute-result\",\n                requestId: data.requestId,\n                results,\n                success: true\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error decreasing attribute:`, error);\n            socketManager.send({\n                type: \"modify-attribute-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n            }\n        });\n        \n        // Handle increase attribute request\n        socketManager.onMessageType(\"increase-attribute\", async (data) => {\n            ModuleLogger.info(`Received increase attribute request for attribute: ${data.attribute}, amount: ${data.amount}`);\n            \n            try {\n            if (!data.uuid && !data.selected) {\n                throw new Error(\"UUID or selected is required\");\n            }\n            if (!data.attribute) throw new Error(\"Attribute path is required\");\n            if (typeof data.amount !== 'number') throw new Error(\"Amount must be a number\");\n            \n            const entities = [];\n            if (data.selected) {\n                const controlledTokens = canvas?.tokens?.controlled || [];\n                for (const token of controlledTokens) {\n                if (token.actor) {\n                    entities.push(token.actor);\n                }\n                }\n            } else if (data.uuid) {\n                const entity = await fromUuid(data.uuid);\n                if (entity) {\n                entities.push(entity);\n                }\n            }\n\n            if (entities.length === 0) {\n                throw new Error(\"No entities found to modify\");\n            }\n\n            const results = [];\n            for (const entity of entities) {\n                // Get current value\n                const currentValue = getProperty(entity, data.attribute);\n                if (typeof currentValue !== 'number') {\n                throw new Error(`Attribute ${data.attribute} is not a number, found: ${typeof currentValue}`);\n                }\n\n                // Calculate new value\n                const newValue = currentValue + data.amount;\n\n                // Prepare update data\n                const updateData: { [key: string]: unknown } = {};\n                updateData[data.attribute] = newValue;\n\n                // Apply the update\n                await entity.update(updateData);\n\n                results.push({\n                uuid: (entity as any).uuid,\n                attribute: data.attribute,\n                oldValue: currentValue,\n                newValue: newValue\n                });\n            }\n\n            socketManager.send({\n                type: \"modify-attribute-result\",\n                requestId: data.requestId,\n                results,\n                success: true\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error increasing attribute:`, error);\n            socketManager.send({\n                type: \"modify-attribute-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n            }\n        });\n        \n        // Handle give item request\n        socketManager.onMessageType(\"give-item\", async (data) => {\n            ModuleLogger.info(`Received give item request from ${data.fromUuid} to ${data.toUuid}`);\n            \n            try {\n            if (!data.toUuid && !data.selected) {\n                throw new Error(\"Target UUID or selected is required\");\n            };\n            if (!data.itemUuid) throw new Error(\"Item UUID is required\");\n            \n            // Get the source actor\n            let fromEntity: any | null = null;\n            if (data.fromUuid) {\n                fromEntity = await fromUuid(data.fromUuid);\n                \n                // Make sure it's an actor\n                if (fromEntity?.documentName !== \"Actor\") {\n                    throw new Error(`Source entity must be an Actor, got ${fromEntity?.documentName}`);\n                }\n            }\n            \n            // Get the target actor\n            if (data.selected) {\n                data.toUuid = canvas?.tokens?.controlled[0]?.actor?.uuid;\n            }\n            const toEntity = await fromUuid(data.toUuid);\n            if (!toEntity) throw new Error(`Target entity not found: ${data.toUuid}`);\n            \n            // Make sure it's an actor\n            if (toEntity.documentName !== \"Actor\") {\n                throw new Error(`Target entity must be an Actor, got ${toEntity.documentName}`);\n            }\n            \n            // Get the item to transfer\n            const itemEntity = await fromUuid(data.itemUuid);\n            if (!itemEntity) throw new Error(`Item not found: ${data.itemUuid}`);\n            \n            // Make sure it's an item\n            if (itemEntity.documentName !== \"Item\") {\n                throw new Error(`Entity must be an Item, got ${itemEntity.documentName}`);\n            }\n            \n            // Make sure the item belongs to the source actor\n            if (data.fromUuid && itemEntity.parent?.id !== fromEntity.id) {\n                throw new Error(`Item ${data.itemUuid} does not belong to source actor ${data.fromUuid}`);\n            }\n            \n            // Create a new item on the target actor\n            const itemData = itemEntity.toObject();\n            delete itemData._id; // Remove the ID so a new one is created\n            \n            // Handle quantity if specified\n            if (data.quantity && typeof data.quantity === 'number') {\n                if (itemData.system && itemData.system.quantity) {\n                const originalQuantity = itemData.system.quantity;\n                itemData.system.quantity = data.quantity;\n                    if (data.fromUuid) {\n                        // If transferring all, delete from source\n                        if (data.quantity >= originalQuantity) {\n                            await itemEntity.delete();\n                        } else {\n                            // Otherwise reduce quantity on source\n                            await itemEntity.update({\"system.quantity\": originalQuantity - data.quantity});\n                        }\n                    }\n                }\n            } else {\n                if (data.fromUuid) {\n                    // Default behavior with no quantity - remove from source\n                    await itemEntity.delete();\n                }\n            }\n            \n            // Create on target\n            const newItem = await toEntity.createEmbeddedDocuments(\"Item\", [itemData]);\n            \n            socketManager.send({\n                type: \"give-item-result\",\n                requestId: data.requestId,\n                fromUuid: data.fromUuid,\n                selected: data.selected,\n                toUuid: data.toUuid,\n                quantity: data.quantity,\n                itemUuid: data.itemUuid,\n                newItemId: newItem[0].id,\n                success: true\n            });\n            } catch (error) {\n            ModuleLogger.error(`Error giving item:`, error);\n            socketManager.send({\n                type: \"give-item-result\",\n                requestId: data.requestId,\n                selected: data.selected,\n                fromUuid: data.fromUuid || \"\",\n                toUuid: data.toUuid || \"\",\n                quantity: data.quantity,\n                itemUuid: data.itemUuid || \"\",\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n\n    socketManager.onMessageType(\"execute-js\", async (data) => {\n        ModuleLogger.info(`Received execute-js request:`, data);\n    \n        try {\n            const { script, requestId } = data;\n    \n            if (!script || typeof script !== \"string\") {\n                throw new Error(\"Invalid script provided\");\n            }\n    \n            // Use an IIFE to safely execute the script\n            let result;\n            try {\n                result = await (async () => {\n                    return eval(`(async () => { ${script} })()`);\n                })();\n            } catch (executionError) {\n                const errorMessage = executionError instanceof Error ? executionError.message : String(executionError);\n                throw new Error(`Error executing script: ${errorMessage}`);\n            }\n    \n            // Send the result back\n            socketManager.send({\n                type: \"execute-js-result\",\n                requestId,\n                success: true,\n                result\n            });\n        } catch (error) {\n            ModuleLogger.error(`Error in execute-js handler:`, error);\n            socketManager.send({\n                type: \"execute-js-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n\n    // Handle select entities request\n    socketManager.onMessageType(\"select-entities\", async (data) => {\n        ModuleLogger.info(`Received select entities request:`, data);\n        \n        try {\n            const scene = (game as Game).scenes?.active;\n            if (!scene) {\n                throw new Error(\"No active scene found\");\n            }\n\n            if (data.overwrite) {\n                // Deselect all tokens if overwrite is true\n                canvas?.tokens?.releaseAll();\n            }\n\n            let targets: TokenDocument[] = [];\n            if (data.all) {\n                // Select all tokens on the active scene\n                targets = scene.tokens?.contents || [];\n            }\n            if (data.uuids && Array.isArray(data.uuids)) {\n                const matchingTokens = scene.tokens?.filter(token => \n                    data.uuids.includes(token.uuid)\n                ) || [];\n                targets = [...targets, ...matchingTokens];\n            }\n            if (data.name) {\n                const matchingTokens = scene.tokens?.filter(token => \n                    token.name?.toLowerCase() === data.name?.toLowerCase()\n                ) || [];\n                targets = [...targets, ...matchingTokens];\n            }\n            if (data.data) {\n                const matchingTokens = scene.tokens?.filter(token => \n                    Object.entries(data.data).every(([key, value]) => {\n                        // Handle nested keys for actor data\n                        if (key.startsWith(\"actor.\") && token.actor) {\n                            const actorKey = key.replace(\"actor.\", \"\");\n                            return getProperty(token.actor, actorKey) === value;\n                        }\n                        // Handle token-level properties\n                        const tokenData = token.toObject();\n                        return getProperty(tokenData, key) === value;\n                    })\n                ) || [];\n                targets = [...targets, ...matchingTokens];\n            }\n\n            if (targets.length === 0) {\n                throw new Error(\"No matching entities found\");\n            }\n\n            // Select each token\n            for (const token of targets) {\n                const t = token.id ? canvas?.tokens?.get(token.id) : null;\n                if (t) {\n                    t.control({ releaseOthers: false });\n                }\n            }\n\n            socketManager.send({\n                type: \"select-entities-result\",\n                requestId: data.requestId,\n                success: true,\n                count: targets.length,\n                message: `${targets.length} entities selected`\n            });\n        } catch (error) {\n            ModuleLogger.error(`Error selecting entities:`, error);\n            socketManager.send({\n                type: \"select-entities-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n\n    // Handle get selected entities request\n    socketManager.onMessageType(\"get-selected-entities\", async (data) => {\n        ModuleLogger.info(`Received get selected entities request:`, data);\n        \n        try {\n            const scene = (game as Game).scenes?.active;\n            if (!scene) {\n                throw new Error(\"No active scene found\");\n            }\n\n            const selectedTokens = canvas?.tokens?.controlled || [];\n            const selectedUuids = selectedTokens.map(token => ({\n                tokenUuid: token.document.uuid,\n                actorUuid: token.actor?.uuid || null\n            }));\n\n            socketManager.send({\n                type: \"selected-entities-result\",\n                requestId: data.requestId,\n                success: true,\n                selected: selectedUuids\n            });\n        } catch (error) {\n            ModuleLogger.error(`Error getting selected entities:`, error);\n            socketManager.send({\n                type: \"selected-entities-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n  \n    // Handle file system structure request\n    socketManager.onMessageType(\"get-file-system\", async (data) => {\n        ModuleLogger.info(`Received get file system request:`, data);\n        \n        try {\n            const path = data.path || \"\";\n            const source = data.source || \"data\";\n            const recursive = !!data.recursive;\n            \n            // Use FilePicker.browse() static method instead of creating a FilePicker instance\n            // This avoids showing a dialog\n            const result = await FilePicker.browse(source, path);\n            \n            // Build file structure response\n            const dirs = Array.isArray(result.dirs) ? result.dirs.map((dir: string) => ({\n                name: dir.split('/').pop() || dir,  // Use dir as fallback if pop returns undefined\n                path: dir,\n                type: 'directory'\n            })) : [];\n            \n            const files = Array.isArray(result.files) ? result.files.map((file: string) => ({\n                name: file.split('/').pop() || file,  // Use file as fallback if pop returns undefined\n                path: file,\n                type: 'file'\n            })) : [];\n            \n            // If recursive, get subdirectories\n            let subdirs: Array<{name: string, path: string, type: string}> = [];\n            if (recursive && dirs.length > 0) {\n                for (const dir of dirs) {\n                    try {\n                        // Use static method for subdirectories as well\n                        const subResult = await FilePicker.browse(source, dir.path);\n                        \n                        // Process directories\n                        const subDirs = Array.isArray(subResult.dirs) ? subResult.dirs.map((subdir: string) => ({\n                            name: subdir.split('/').pop() || subdir,  // Add fallback\n                            path: subdir,\n                            type: 'directory'\n                        })) : [];\n                        \n                        // Process files\n                        const subFiles = Array.isArray(subResult.files) ? subResult.files.map((file: string) => ({\n                            name: file.split('/').pop() || file,  // Add fallback\n                            path: file,\n                            type: 'file'\n                        })) : [];\n                        \n                        // Add to subdirs collection\n                        subdirs = subdirs.concat(subDirs, subFiles);\n                        \n                        // If deeply recursive, process subdirectories of subdirectories\n                        if (recursive === true && subDirs.length > 0 && dir.path.split('/').length < 3) {\n                            for (const subDir of subDirs) {\n                                try {\n                                    const deepResult = await FilePicker.browse(source, subDir.path);\n                                    \n                                    const deepDirs = Array.isArray(deepResult.dirs) ? deepResult.dirs.map((deepdir: string) => ({\n                                        name: deepdir.split('/').pop() || deepdir,  // Add fallback\n                                        path: deepdir,\n                                        type: 'directory'\n                                    })) : [];\n                                    \n                                    const deepFiles = Array.isArray(deepResult.files) ? deepResult.files.map((file: string) => ({\n                                        name: file.split('/').pop() || file,  // Add fallback\n                                        path: file,\n                                        type: 'file'\n                                    })) : [];\n                                    \n                                    subdirs = subdirs.concat(deepDirs, deepFiles);\n                                } catch (deepError) {\n                                    ModuleLogger.error(`Error processing deep subdirectory ${subDir.path}:`, deepError);\n                                }\n                            }\n                        }\n                    } catch (error) {\n                        ModuleLogger.error(`Error processing subdirectory ${dir.path}:`, error);\n                    }\n                }\n            }\n            \n            const results = [...dirs, ...files];\n            if (recursive) {\n                results.push(...subdirs);\n            }\n            \n            socketManager.send({\n                type: \"file-system-result\",\n                requestId: data.requestId,\n                success: true,\n                path,\n                source,\n                results,\n                recursive\n            });\n        } catch (error) {\n            ModuleLogger.error(`Error getting file system:`, error);\n            socketManager.send({\n                type: \"file-system-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n    \n    // Handle file upload request\n    socketManager.onMessageType(\"upload-file\", async (data) => {\n        ModuleLogger.info(`Received upload file request:`, data);\n        \n        try {\n            const { path, filename, source, fileData, mimeType, binaryData, overwrite } = data;\n            \n            if (!path || !filename) {\n                throw new Error(\"Missing required parameters (path, filename)\");\n            }\n            \n            let file;\n            \n            // Handle binary data (new method)\n            if (binaryData) {\n                // Create a Uint8Array from the binary data\n                const bytes = new Uint8Array(binaryData);\n                const blob = new Blob([bytes], { type: mimeType || 'application/octet-stream' });\n                file = new File([blob], filename, { type: mimeType || 'application/octet-stream' });\n            } \n            // Handle base64 data (legacy method)\n            else if (fileData) {\n                // Convert base64 to blob\n                const base64Data = fileData.split(',')[1]; // Remove the data URL prefix\n                const binaryData = atob(base64Data);\n                const bytes = new Uint8Array(binaryData.length);\n                for (let i = 0; i < binaryData.length; i++) {\n                    bytes[i] = binaryData.charCodeAt(i);\n                }\n                const blob = new Blob([bytes], { type: mimeType || 'application/octet-stream' });\n                file = new File([blob], filename, { type: mimeType || 'application/octet-stream' });\n            } else {\n                throw new Error(\"Missing file data (either binaryData or fileData is required)\");\n            }\n            \n            // Use Foundry's upload method with proper type handling\n            const uploadSource = source || \"data\";\n\n            // Check if the path exists, and create it if it doesn't\n            try {\n                // Split the path into individual directories\n                const directories = path.split('/');\n                let currentPath = '';\n\n                // Iterate through each directory and create it if it doesn't exist\n                for (const directory of directories) {\n                    currentPath = currentPath ? `${currentPath}/${directory}` : directory;\n                    try {\n                        await FilePicker.createDirectory(uploadSource, currentPath);\n                    } catch (createDirError) {\n                        // Ignore error if directory already exists\n                        if (!(createDirError as any).message.includes(\"already exists\")) {\n                            ModuleLogger.error(`Error creating directory:`, createDirError);\n                            throw new Error(`Could not create directory: ${(createDirError as Error).message}`);\n                        }\n                    }\n                }\n            } catch (createDirError) {\n                ModuleLogger.error(`Error creating directory:`, createDirError);\n                throw new Error(`Could not create directory: ${(createDirError as Error).message}`);\n            }\n\n            // Check if the file exists\n            let existingFile = null;\n            try {\n                const filePath = path + '/' + filename;\n                existingFile = await FilePicker.browse(uploadSource, filePath);\n            } catch (e) {\n                // File does not exist, which is fine\n            }\n\n            // If the file exists and overwrite is not true, throw an error\n            if (existingFile && !overwrite) {\n                throw new Error(\"File already exists. Set overwrite to true to replace it.\");\n            }\n\n            const result = await FilePicker.upload(uploadSource, path, file);\n            \n            socketManager.send({\n                type: \"upload-file-result\",\n                requestId: data.requestId,\n                success: true,\n                path: result && typeof result === 'object' && 'path' in result ? result.path : path + '/' + filename\n            });\n        } catch (error) {\n            ModuleLogger.error(`Error uploading file:`, error);\n            socketManager.send({\n                type: \"upload-file-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n    \n    // Handle file download request\n    socketManager.onMessageType(\"download-file\", async (data) => {\n        ModuleLogger.info(`Received download file request:`, data);\n        \n        try {\n            const { path } = data;\n            // We don't use source here as it's handled by the path\n            \n            if (!path) {\n                throw new Error(\"Missing required parameter (path)\");\n            }\n            \n            // Fetch the file from the server\n            const response = await fetch(path.startsWith('http') ? path : foundry.utils.getRoute(path));\n            \n            if (!response.ok) {\n                throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);\n            }\n            \n            // Convert to base64\n            const blob = await response.blob();\n            const reader = new FileReader();\n            const fileData = await new Promise<string>((resolve, reject) => {\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n            \n            socketManager.send({\n                type: \"download-file-result\",\n                requestId: data.requestId,\n                success: true,\n                path,\n                fileData,\n                filename: path.split('/').pop() || 'file',\n                mimeType: blob.type\n            });\n        } catch (error) {\n            ModuleLogger.error(`Error downloading file:`, error);\n            socketManager.send({\n                type: \"download-file-result\",\n                requestId: data.requestId,\n                success: false,\n                error: (error as Error).message\n            });\n        }\n    });\n  \n    } catch (error) {\n      ModuleLogger.error(`Error initializing WebSocket:`, error);\n    }\n}\n","// src/ts/module.ts\nimport \"../styles/style.scss\";\nimport { FoundryRestApi } from \"./types\";\nimport { moduleId, recentRolls, MAX_ROLLS_STORED } from \"./constants\";\nimport { ModuleLogger } from \"./utils/logger\";\nimport { initializeWebSocket } from \"./network/webSocketEndpoints\";\n\n// Declare QuickInsert interface\ndeclare global {\n  interface Window {\n    QuickInsert: {\n      open: (context: any) => void;\n      search: (text: string, filter?: ((item: any) => boolean) | null, max?: number) => Promise<any[]>;\n      forceIndex: () => void;\n      handleKeybind: (event: KeyboardEvent, context: any) => void;\n      hasIndex: boolean;\n    };\n  }\n}\n\nHooks.once(\"init\", () => {\n  console.log(`Initializing ${moduleId}`);\n  \n  // Register module settings for WebSocket configuration\n  (game as Game).settings.register(moduleId, \"wsRelayUrl\", {\n    name: \"Local Relay Server URL\",\n    hint: \"URL for the local FoundryVTT relay server (WebSocket connection)\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    default: \"ws://localhost:3001/ws\",\n    requiresReload: true\n  } as any);\n  \n  (game as Game).settings.register(moduleId, \"apiKey\", {\n    name: \"API Key\",\n    hint: \"API Key for authentication with the local relay server (generated automatically)\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    default: (game as Game).world.id,\n    requiresReload: true\n  } as any);\n\n  (game as Game).settings.register(moduleId, \"logLevel\", {\n    name: \"Log Level\",\n    hint: \"Set the level of detail for module logging\",\n    scope: \"world\",\n    config: true,\n    type: Number,\n    choices: {\n      0: \"debug\",\n      1: \"info\",\n      2: \"warn\",\n      3: \"error\"\n    } as any,\n    default: 2\n  });\n\n  // Add new settings for connection management\n  (game as Game).settings.register(moduleId, \"pingInterval\", {\n    name: \"Ping Interval (seconds)\",\n    hint: \"How often (in seconds) the module sends a ping to the local relay server to keep the connection alive.\",\n    scope: \"world\",\n    config: true,\n    type: Number,\n    default: 30,\n    range: {\n      min: 5,\n      max: 600,\n      step: 1\n    },\n    requiresReload: true\n  } as any);\n\n  (game as Game).settings.register(moduleId, \"reconnectMaxAttempts\", {\n    name: \"Max Reconnect Attempts\",\n    hint: \"Maximum number of times the module will try to reconnect after losing connection.\",\n    scope: \"world\",\n    config: true,\n    type: Number,\n    default: 20,\n    requiresReload: true\n  } as any);\n\n  (game as Game).settings.register(moduleId, \"reconnectBaseDelay\", {\n    name: \"Reconnect Base Delay (ms)\",\n    hint: \"Initial delay (in milliseconds) before the first reconnect attempt. Subsequent attempts use exponential backoff.\",\n    scope: \"world\",\n    config: true,\n    type: Number,\n    default: 1000,\n    requiresReload: true\n  } as any);\n\n  // Create and expose module API\n  const module = (game as Game).modules.get(moduleId) as FoundryRestApi;\n  module.api = {\n    getWebSocketManager: () => {\n      if (!module.socketManager) {\n        ModuleLogger.warn(`WebSocketManager requested but not initialized`);\n        return null;\n      }\n      return module.socketManager;\n    },\n    search: async (query: string, filter?: string) => {\n      if (!window.QuickInsert) {\n        ModuleLogger.error(`QuickInsert not available`);\n        return [];\n      }\n      \n      if (!window.QuickInsert.hasIndex) {\n        ModuleLogger.info(`QuickInsert index not ready, forcing index creation`);\n        try {\n          window.QuickInsert.forceIndex();\n          await new Promise(resolve => setTimeout(resolve, 500));\n        } catch (error) {\n          ModuleLogger.error(`Failed to force QuickInsert index:`, error);\n        }\n      }\n      \n      let filterFunc = null;\n      if (filter) {\n        filterFunc = (item: any) => item.documentType === filter;\n      }\n      \n      return window.QuickInsert.search(query, filterFunc, 100);\n    },\n    getByUuid: async (uuid: string) => {\n      try {\n        return await fromUuid(uuid);\n      } catch (error) {\n        ModuleLogger.error(`Error getting entity by UUID:`, error);\n        return null;\n      }\n    }\n  };\n});\n\n// Replace the API key input field with a password field\nHooks.on(\"renderSettingsConfig\", (_: SettingsConfig, html: JQuery) => {\n  const apiKeyInput = html.find(`input[name=\"${moduleId}.apiKey\"]`);\n  if (apiKeyInput.length) {\n    // Change the input type to password\n    apiKeyInput.attr(\"type\", \"password\");\n\n    // Add an event listener to save the value when it changes\n    apiKeyInput.on(\"change\", (event) => {\n      const newValue = (event.target as HTMLInputElement).value;\n      (game as Game).settings.set(moduleId, \"apiKey\", newValue).then(() => {\n        new Dialog({\n          title: \"Reload Required\",\n          content: \"<p>The API Key has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>\",\n          buttons: {\n            yes: {\n              label: \"Reload\",\n              callback: () => window.location.reload()\n            },\n            no: {\n              label: \"Later\"\n            }\n          },\n          default: \"yes\"\n        }).render(true);\n      });\n    });\n  }\n});\n\nHooks.once(\"ready\", () => {\n  setTimeout(() => {\n    initializeWebSocket();\n  }, 1000);\n});\n\nHooks.on(\"createChatMessage\", (message: any) => {\n  if (message.isRoll && message.rolls?.length > 0) {\n    ModuleLogger.info(`Detected dice roll from ${message.user?.name || 'unknown'}`);\n    \n    // Generate a unique ID using the message ID to prevent duplicates\n    const rollId = message.id;\n    \n    // Format roll data\n    const rollData = {\n      id: rollId,\n      messageId: message.id,\n      user: {\n        id: message.user?.id,\n        name: message.user?.name\n      },\n      speaker: message.speaker,\n      flavor: message.flavor || \"\",\n      rollTotal: message.rolls[0].total,\n      formula: message.rolls[0].formula,\n      isCritical: message.rolls[0].isCritical || false,\n      isFumble: message.rolls[0].isFumble || false,\n      dice: message.rolls[0].dice?.map((d: any) => ({\n        faces: d.faces,\n        results: d.results.map((r: any) => ({\n          result: r.result,\n          active: r.active\n        }))\n      })),\n      timestamp: Date.now()\n    };\n    \n    // Check if this roll ID already exists in recentRolls\n    const existingIndex = recentRolls.findIndex(roll => roll.id === rollId);\n    if (existingIndex !== -1) {\n      // If it exists, update it instead of adding a new entry\n      recentRolls[existingIndex] = rollData;\n    } else {\n      // Add to recent rolls\n      recentRolls.unshift(rollData);\n      \n      // Trim the array if needed\n      if (recentRolls.length > MAX_ROLLS_STORED) {\n        recentRolls.length = MAX_ROLLS_STORED;\n      }\n    }\n    \n    // Send to local relay server if connected\n    const module = (game as Game).modules.get(moduleId) as FoundryRestApi;\n    if (module.socketManager?.isConnected()) {\n      module.socketManager.send({\n        type: \"roll-data\",\n        data: rollData\n      });\n    }\n  }\n});\n"],"names":["message","args","WSCloseCodes","_WebSocketManager","url","token","__publicField","_a","_b","_c","currentUserId","activeGMs","_d","u","sortedGMs","a","b","isPrimary","_e","_f","wasPrimary","wsUrl","connectionTimeout","event","error","data","type","handler","_event","pingIntervalSeconds","pingIntervalMs","maxAttempts","baseDelay","delay","filterStr","filters","parts","part","key","value","result","itemConstructorName","packageValue","folderValue","folderIdMatch","propertyValue","current","entity","serialized","attrKey","attrValue","subKey","subValue","propKey","itemCollection","i","itemEntries","_","item","err","effectCollection","effectEntries","effect","resolve","filterFunc","filteredResults","entityData","entityUUID","controlledTokens","folders","folder","compendiums","pack","contents","entry","folderMatch","folderId","DocumentClass","createData","entities","updatedEntities","e","formula","itemUuid","flavor","createChatMessage","speaker","target","whisper","requestId","rollResult","speakerData","rollMode","speakerEntity","activeScene","tokens","t","document","messageId","targetAcquired","targetToken","targetDocument","_g","_h","_i","targetObject","_j","_k","useOptions","originalRenderDialog","defaultButton","firstButton","useResult","cardResult","chatOptions","chatResult","displayCard","chatData","_l","_n","_m","roll","term","d","r","actor","sheet","extractClassesAndIds","element","className","classNames","ids","html","css","sheetAppId","style","tempDiv","uniqueClassNames","uniqueIds","allStyles","allLinks","styleContent","id","stylesheetPromises","link","href","fullUrl","response","baseUrl","coreStylesheets","existingCSSPaths","corePromises","path","allPromises","match","src","renderError","macros","macro","currentPage","hotbarData","userData","hotbarFlags","directHotbar","slot","macroId","encounters","combat","c","tokensData","uuid","addedTokenIds","currentScene","tokenData","selectedTokens","encounterId","addedEntities","failedEntities","combatantData","scene","tokenForActor","removedEntities","combatantIdsToRemove","foundCombatant","combatant","combatants","validIds","results","success","deadEffect","tokensUpdated","scenes","currentValue","newValue","updateData","fromEntity","toEntity","itemEntity","itemData","originalQuantity","newItem","executionError","errorMessage","targets","matchingTokens","actorKey","selectedUuids","source","recursive","dirs","dir","files","file","subdirs","subResult","subDirs","subdir","subFiles","subDir","deepResult","deepDirs","deepdir","deepFiles","deepError","filename","fileData","mimeType","binaryData","overwrite","bytes","blob","base64Data","uploadSource","directories","currentPath","directory","createDirError","existingFile","filePath","reader","reject","module","query","filter","apiKeyInput","rollId","rollData","existingIndex"],"mappings":"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"}