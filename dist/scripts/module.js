var F=Object.defineProperty;var G=(e,n,r)=>n in e?F(e,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[n]=r;var E=(e,n,r)=>G(e,typeof n!="symbol"?n+"":n,r);const id="foundry-rest-api",moduleId=id,recentRolls=[],MAX_ROLLS_STORED=20;class ModuleLogger{static debugLevel(){return game.settings.get(moduleId,"logLevel")}static debug(n,...r){this.debugLevel()<1&&console.log(`${moduleId} | ${n}`,...r)}static info(n,...r){this.debugLevel()<2&&console.log(`${moduleId} | ${n}`,...r)}static warn(n,...r){this.debugLevel()<3&&console.warn(`${moduleId} | ${n}`,...r)}static error(n,...r){this.debugLevel()<4&&console.error(`${moduleId} | ${n}`,...r)}}var WSCloseCodes=(e=>(e[e.Normal=1e3]="Normal",e[e.NoClientId=4001]="NoClientId",e[e.NoAuth=4002]="NoAuth",e[e.NoConnectedGuild=4003]="NoConnectedGuild",e[e.InternalError=4e3]="InternalError",e[e.DuplicateConnection=4004]="DuplicateConnection",e[e.ServerShutdown=4005]="ServerShutdown",e))(WSCloseCodes||{});const A=class A{constructor(n,r){E(this,"url");E(this,"token");E(this,"socket",null);E(this,"messageHandlers",new Map);E(this,"reconnectTimer",null);E(this,"reconnectAttempts",0);E(this,"clientId");E(this,"pingInterval",null);E(this,"isConnecting",!1);E(this,"isPrimaryGM",!1);var s,o,i;this.url=n,this.token=r,this.clientId=`foundry-${((s=game.user)==null?void 0:s.id)||Math.random().toString(36).substring(2,15)}`,this.isPrimaryGM=this.checkIfPrimaryGM(),ModuleLogger.info(`Created WebSocketManager with clientId: ${this.clientId}, isPrimaryGM: ${this.isPrimaryGM}`),(o=game.user)!=null&&o.isGM&&((i=game.user)==null?void 0:i.role)===4&&(Hooks.on("userConnected",this.reevaluatePrimaryGM.bind(this)),Hooks.on("userDisconnected",this.reevaluatePrimaryGM.bind(this)))}static getInstance(n,r){var s,o;return!((s=game.user)!=null&&s.isGM)||((o=game.user)==null?void 0:o.role)!==4?(ModuleLogger.info("WebSocketManager not created - user is not a full GM"),null):(A.instance||(ModuleLogger.info("Creating new WebSocketManager instance"),A.instance=new A(n,r)),A.instance)}checkIfPrimaryGM(){var i,t,a,c,u,l;if(!((i=game.user)!=null&&i.isGM)||((t=game.user)==null?void 0:t.role)!==4)return!1;const n=(a=game.user)==null?void 0:a.id,r=((c=game.users)==null?void 0:c.filter(g=>g.role===4&&g.active))||[];if(r.length===0)return!1;const s=[...r].sort((g,m)=>(g.id||"").localeCompare(m.id||"")),o=((u=s[0])==null?void 0:u.id)===n;return ModuleLogger.info(`Primary GM check - Current user: ${n}, Primary GM: ${(l=s[0])==null?void 0:l.id}, isPrimary: ${o}`),o}reevaluatePrimaryGM(){const n=this.isPrimaryGM;this.isPrimaryGM=this.checkIfPrimaryGM(),n!==this.isPrimaryGM&&(ModuleLogger.info(`Primary GM status changed: ${n} -> ${this.isPrimaryGM}`),this.isPrimaryGM&&!this.isConnected()&&(ModuleLogger.info("Taking over as primary GM, connecting WebSocket"),this.connect()),!this.isPrimaryGM&&this.isConnected()&&(ModuleLogger.info("No longer primary GM, disconnecting WebSocket"),this.disconnect()))}connect(){var n,r;if(!((n=game.user)!=null&&n.isGM)||((r=game.user)==null?void 0:r.role)!==4){ModuleLogger.info("WebSocket connection aborted - user is not a full GM");return}if(!this.isPrimaryGM){ModuleLogger.info("WebSocket connection aborted - user is not the primary GM");return}if(this.isConnecting){ModuleLogger.info("Already attempting to connect");return}if(this.socket&&(this.socket.readyState===WebSocket.CONNECTING||this.socket.readyState===WebSocket.OPEN)){ModuleLogger.info("WebSocket already connected or connecting");return}this.isConnecting=!0;try{const s=new URL(this.url);s.searchParams.set("id",this.clientId),s.searchParams.set("token",this.token),ModuleLogger.info(`Connecting to WebSocket at ${s.toString()}`),this.socket=new WebSocket(s.toString());const o=window.setTimeout(()=>{this.socket&&this.socket.readyState===WebSocket.CONNECTING&&(ModuleLogger.error("Connection timed out"),this.socket.close(),this.socket=null,this.isConnecting=!1,this.scheduleReconnect())},5e3);this.socket.addEventListener("open",i=>{window.clearTimeout(o),this.onOpen(i)}),this.socket.addEventListener("close",i=>{window.clearTimeout(o),this.onClose(i)}),this.socket.addEventListener("error",i=>{window.clearTimeout(o),this.onError(i)}),this.socket.addEventListener("message",this.onMessage.bind(this))}catch(s){ModuleLogger.error("Error creating WebSocket:",s),this.isConnecting=!1,this.scheduleReconnect()}}disconnect(){this.socket&&(ModuleLogger.info("Disconnecting WebSocket"),this.socket.close(WSCloseCodes.Normal,"Disconnecting"),this.socket=null),this.reconnectTimer!==null&&(window.clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),this.reconnectAttempts=0,this.isConnecting=!1}isConnected(){return this.socket!==null&&this.socket.readyState===WebSocket.OPEN}send(n){var r,s;if(ModuleLogger.info(`Send called, readyState: ${(r=this.socket)==null?void 0:r.readyState}`),this.socket&&this.socket.readyState===WebSocket.OPEN)try{return ModuleLogger.info("Sending message:",n),this.socket.send(JSON.stringify(n)),!0}catch(o){return ModuleLogger.error("Error sending message:",o),!1}else return ModuleLogger.warn(`WebSocket not ready, state: ${(s=this.socket)==null?void 0:s.readyState}`),!1}onMessageType(n,r){this.messageHandlers.set(n,r)}onOpen(n){ModuleLogger.info("WebSocket connected"),this.isConnecting=!1,this.reconnectAttempts=0,this.send({type:"ping"});const r=game.settings.get(moduleId,"pingInterval"),s=r*1e3;ModuleLogger.info(`Starting application ping interval: ${r} seconds`),this.pingInterval!==null&&window.clearInterval(this.pingInterval),this.pingInterval=window.setInterval(()=>{this.isConnected()&&this.send({type:"ping"})},s)}onClose(n){ModuleLogger.info(`WebSocket disconnected: ${n.code} - ${n.reason}`),this.socket=null,this.isConnecting=!1,this.pingInterval!==null&&(window.clearInterval(this.pingInterval),this.pingInterval=null),n.code!==WSCloseCodes.Normal&&this.isPrimaryGM&&this.scheduleReconnect()}onError(n){ModuleLogger.error("WebSocket error:",n),this.isConnecting=!1}async onMessage(n){try{const r=JSON.parse(n.data);ModuleLogger.info("Received message:",r),r.type&&this.messageHandlers.has(r.type)?(ModuleLogger.info(`Handling message of type: ${r.type}`),this.messageHandlers.get(r.type)(r)):r.type&&ModuleLogger.warn(`No handler for message type: ${r.type}`)}catch(r){ModuleLogger.error("Error processing message:",r)}}scheduleReconnect(){if(this.reconnectTimer!==null)return;const n=game.settings.get(moduleId,"reconnectMaxAttempts"),r=game.settings.get(moduleId,"reconnectBaseDelay");if(this.reconnectAttempts++,this.reconnectAttempts>n){ModuleLogger.error(`Maximum reconnection attempts (${n}) reached`),this.reconnectAttempts=0;return}const s=Math.min(3e4,r*Math.pow(2,this.reconnectAttempts-1));ModuleLogger.info(`Scheduling reconnect in ${s}ms (attempt ${this.reconnectAttempts}/${n})`),this.reconnectTimer=window.setTimeout(()=>{this.reconnectTimer=null,this.isPrimaryGM?(ModuleLogger.info("Attempting reconnect..."),this.connect()):(ModuleLogger.info("Reconnect attempt aborted - no longer primary GM."),this.reconnectAttempts=0)},s)}};E(A,"instance",null);let WebSocketManager=A;function parseFilterString(e){if(!e.includes(":"))return{documentType:e};const n={},r=e.split(",");for(const s of r)if(s.includes(":")){const[o,i]=s.split(":");o&&i&&(n[o.trim()]=i.trim())}return n}function matchesAllFilters(e,n){var r,s;for(const[o,i]of Object.entries(n)){if(!i)continue;if(o==="resultType"){const a=(s=(r=e.item)==null?void 0:r.constructor)==null?void 0:s.name;if(!a||a.toLowerCase()!==i.toLowerCase())return!1;continue}if(o==="package"&&e.item){const a=e.item.package;if(!a||a.toLowerCase()!==i.toLowerCase()&&`Compendium.${a}`.toLowerCase()!==i.toLowerCase())return!1;continue}if(o==="folder"&&e.item){const a=e.item.folder;if(!a&&i)return!1;if(a){const c=typeof a=="object"?a.id:a;if(i===c||i===`Folder.${c}`||`Folder.${i}`===c)continue;return!1}continue}let t;if(!o.includes(".")&&e.item&&e.item[o]!==void 0)t=e.item[o];else{const a=o.split(".");let c=e;for(const u of a){if(c==null){t=void 0;break}c=c[u]}t=c}if(t===void 0||typeof t=="string"&&t.toLowerCase()!==i.toLowerCase())return!1}return!0}function deepSerializeEntity(e){var n,r,s,o,i;if(!e)return null;try{let t=e.toObject?e.toObject(!0):JSON.parse(JSON.stringify(e));if(e.system){if(e.system.attributes){for(const[a,c]of Object.entries(e.system.attributes))if(((r=(n=t.system)==null?void 0:n.attributes)==null?void 0:r[a])===null&&c!==null&&(t.system.attributes||(t.system.attributes={}),t.system.attributes[a]=JSON.parse(JSON.stringify(c))),typeof c=="object"&&c!==null)for(const[u,l]of Object.entries(c))((i=(o=(s=t.system)==null?void 0:s.attributes)==null?void 0:o[a])==null?void 0:i[u])===null&&l!==null&&(t.system.attributes[a]||(t.system.attributes[a]={}),t.system.attributes[a][u]=JSON.parse(JSON.stringify(l)))}["traits","abilities","skills","resources"].forEach(a=>{var c,u,l,g,m;if(e.system[a]){for(const[f,y]of Object.entries(e.system[a]))if(((u=(c=t.system)==null?void 0:c[a])==null?void 0:u[f])===null&&y!==null&&(t.system[a]||(t.system[a]={}),t.system[a][f]=JSON.parse(JSON.stringify(y))),typeof y=="object"&&y!==null)for(const[h,b]of Object.entries(y))((m=(g=(l=t.system)==null?void 0:l[a])==null?void 0:g[f])==null?void 0:m[h])===null&&b!==null&&(t.system[a][f]||(t.system[a][f]={}),t.system[a][f][h]=JSON.parse(JSON.stringify(b)))}})}if(e.items&&e.items.size>0&&Array.isArray(t.items))try{const a=e.items;if(Array.isArray(a.contents))for(let c=0;c<a.contents.length;c++)c<t.items.length&&(t.items[c]=deepSerializeEntity(a.contents[c]));else if(typeof a.entries=="function"){const c=Array.from(a.entries());for(let u=0;u<c.length;u++){const[l,g]=c[u];u<t.items.length&&(t.items[u]=deepSerializeEntity(g))}}}catch(a){ModuleLogger.warn("Failed to process entity.items collection:",a)}if(e.effects&&e.effects.size>0&&Array.isArray(t.effects))try{const a=e.effects;if(Array.isArray(a.contents))for(let c=0;c<a.contents.length;c++)c<t.effects.length&&(t.effects[c]=deepSerializeEntity(a.contents[c]));else if(typeof a.entries=="function"){const c=Array.from(a.entries());for(let u=0;u<c.length;u++){const[l,g]=c[u];u<t.effects.length&&(t.effects[u]=deepSerializeEntity(g))}}}catch(a){ModuleLogger.warn("Failed to process entity.effects collection:",a)}return t}catch(t){return ModuleLogger.error("Error deep serializing entity:",t),e.toObject?e.toObject():e}}function initializeWebSocket(){const wsRelayUrl=game.settings.get(moduleId,"wsRelayUrl"),apiKey=game.settings.get(moduleId,"apiKey"),module=game.modules.get(moduleId);if(!wsRelayUrl){ModuleLogger.error("Local relay server URL is empty. Please configure it in module settings.");return}ModuleLogger.info(`Initializing WebSocket connection to local relay server: ${wsRelayUrl}`);try{if(module.socketManager?ModuleLogger.info("WebSocket manager already exists, not creating a new one"):(module.socketManager=WebSocketManager.getInstance(wsRelayUrl,apiKey),module.socketManager&&module.socketManager.connect()),!module.socketManager){ModuleLogger.warn("No WebSocket manager available, skipping message handler setup");return}const socketManager=module.socketManager;socketManager.onMessageType("ping",()=>{ModuleLogger.info("Received ping, sending pong"),socketManager.send({type:"pong"})}),socketManager.onMessageType("pong",()=>{ModuleLogger.info("Received pong")}),socketManager.onMessageType("perform-search",async e=>{ModuleLogger.info("Received search request:",e);try{if(!window.QuickInsert){ModuleLogger.error("QuickInsert not available"),socketManager.send({type:"search-results",requestId:e.requestId,query:e.query,error:"QuickInsert not available",results:[]});return}if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(s=>setTimeout(s,500))}catch(s){ModuleLogger.error("Failed to force QuickInsert index:",s),socketManager.send({type:"search-results",requestId:e.requestId,query:e.query,error:"QuickInsert index not ready",results:[]});return}}let n=null;if(e.filter){const s=typeof e.filter=="string"?parseFilterString(e.filter):e.filter;n=o=>matchesAllFilters(o,s)}const r=await window.QuickInsert.search(e.query,n,200);ModuleLogger.info(`Search returned ${r.length} results`),socketManager.send({type:"search-results",requestId:e.requestId,query:e.query,filter:e.filter,results:r.map(s=>{var i;const o=s.item;return{documentType:o.documentType,folder:o.folder,id:o.id,name:o.name,package:o.package,packageName:o.packageName,subType:o.subType,uuid:o.uuid,icon:o.icon,journalLink:o.journalLink,tagline:o.tagline||"",formattedMatch:s.formattedMatch||"",resultType:(i=o.constructor)==null?void 0:i.name}})})}catch(n){ModuleLogger.error("Error performing search:",n),socketManager.send({type:"search-results",requestId:e.requestId,query:e.query,error:n.message,results:[]})}}),socketManager.onMessageType("get-entity",async e=>{var n;ModuleLogger.info("Received entity request:",e);try{let r,s=[],o=e.uuid;if(e.selected){const i=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(i)for(let t of i)e.actor?r=t.actor:r=t.document,r&&(o=r.uuid,s.push(deepSerializeEntity(r)))}else r=await fromUuid(e.uuid),s=r?deepSerializeEntity(r):null;if(!s){ModuleLogger.error(`Entity not found: ${e.uuid}`),socketManager.send({type:"entity-data",requestId:e.requestId,uuid:e.uuid,error:"Entity not found",data:null});return}ModuleLogger.info(`Sending entity data for: ${e.uuid}`,s),socketManager.send({type:"entity-data",requestId:e.requestId,uuid:o,data:s})}catch(r){ModuleLogger.error("Error getting entity:",r),socketManager.send({type:"entity-data",requestId:e.requestId,uuid:e.uuid,error:r.message,data:null})}}),socketManager.onMessageType("get-structure",async e=>{var n;ModuleLogger.info("Received structure request");try{const r=Object.entries(((n=game.folders)==null?void 0:n.contents)||[]).map(([o,i])=>{var t;return{id:i.id,name:i.name,type:i.type,parent:(t=i.parent)==null?void 0:t.id,path:i.uuid,sorting:i.sort,sortingMode:i.sortingMode}}),s=game.packs.contents.map(o=>({id:o.collection,name:o.metadata.label,path:`Compendium.${o.collection}`,entity:o.documentName,package:o.metadata.package,packageType:o.metadata.type,system:o.metadata.system}));socketManager.send({type:"structure-data",requestId:e.requestId,folders:r,compendiums:s})}catch(r){ModuleLogger.error("Error getting structure:",r),socketManager.send({type:"structure-data",requestId:e.requestId,error:r.message,folders:[],compendiums:[]})}}),socketManager.onMessageType("get-contents",async e=>{var n;ModuleLogger.info(`Received contents request for path: ${e.path}`);try{let r=[];if(e.path.startsWith("Compendium.")){const s=game.packs.get(e.path.replace("Compendium.",""));if(!s)throw new Error(`Compendium not found: ${e.path}`);r=(await s.getIndex()).contents.map(i=>({uuid:`${s.collection}.${i._id}`,id:i._id,name:i.name,img:"img"in i?i.img:null,type:"type"in i?i.type:null}))}else{const s=e.path.match(/Folder\.([a-zA-Z0-9]+)/);if(!s)throw new Error(`Invalid folder path: ${e.path}`);const o=s[1],i=(n=game.folders)==null?void 0:n.get(o);if(!i)throw new Error(`Folder not found: ${e.path}`);r=i.contents.map(t=>({uuid:t.uuid,id:t.id,name:t.name,img:"img"in t?t.img:null,type:t.documentName}))}socketManager.send({type:"contents-data",requestId:e.requestId,path:e.path,entities:r})}catch(r){ModuleLogger.error("Error getting contents:",r),socketManager.send({type:"contents-data",requestId:e.requestId,path:e.path,error:r.message,entities:[]})}}),socketManager.onMessageType("create-entity",async e=>{ModuleLogger.info(`Received create entity request for type: ${e.entityType}`);try{const n=getDocumentClass(e.entityType);if(!n)throw new Error(`Invalid entity type: ${e.entityType}`);const r={...e.data,folder:e.folder||null},s=await n.create(r);if(!s)throw new Error("Failed to create entity");socketManager.send({type:"entity-created",requestId:e.requestId,uuid:s.uuid,entity:s.toObject()})}catch(n){ModuleLogger.error("Error creating entity:",n),socketManager.send({type:"entity-created",requestId:e.requestId,error:n.message,message:"Failed to create entity"})}}),socketManager.onMessageType("update-entity",async e=>{var n;ModuleLogger.info(`Received update entity request for UUID: ${e.uuid}`);try{let r=[];if(e.uuid)r.push(await fromUuid(e.uuid));else if(e.selected){const o=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(o)for(let i of o)e.actor?r.push(i.actor):r.push(i.document)}if(r.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let o of r)await(o==null?void 0:o.update(e.updateData));let s=[];for(let o of r)s.push(await fromUuid(o.uuid));socketManager.send({type:"entity-updated",requestId:e.requestId,uuid:e.uuid,entity:s.map(o=>o==null?void 0:o.toObject())})}catch(r){ModuleLogger.error("Error updating entity:",r),socketManager.send({type:"entity-updated",requestId:e.requestId,uuid:e.uuid,error:r.message,message:"Failed to update entity"})}}),socketManager.onMessageType("delete-entity",async e=>{var n;ModuleLogger.info(`Received delete entity request for UUID: ${e.uuid}`);try{let r=[];if(e.uuid)r.push(await fromUuid(e.uuid));else if(e.selected){const s=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;if(s)for(let o of s)e.actor?r.push(o.actor):r.push(o.document)}if(!r||r.length===0)throw new Error(`Entity not found: ${e.uuid}`);for(let s of r)await(s==null?void 0:s.delete());socketManager.send({type:"entity-deleted",requestId:e.requestId,uuid:e.uuid,success:!0})}catch(r){ModuleLogger.error("Error deleting entity:",r),socketManager.send({type:"entity-deleted",requestId:e.requestId,uuid:e.uuid,error:r.message,message:"Failed to delete entity"})}}),socketManager.onMessageType("get-rolls",async e=>{ModuleLogger.info("Received request for roll data"),socketManager.send({type:"rolls-data",requestId:e.requestId,data:recentRolls.slice(0,e.limit||20)})}),socketManager.onMessageType("get-last-roll",e=>{ModuleLogger.info("Received request for last roll data"),socketManager.send({type:"last-roll-data",requestId:e.requestId,data:recentRolls.length>0?recentRolls[0]:null})}),socketManager.onMessageType("perform-roll",async e=>{var n,r,s,o,i,t,a,c,u,l,g,m,f,y;try{const{formula:h,itemUuid:b,flavor:v,createChatMessage:N,speaker:$,target:U,whisper:C,requestId:D}=e;let R,T={},p=C&&C.length>0?CONST.DICE_ROLL_MODES.PRIVATE:CONST.DICE_ROLL_MODES.PUBLIC;if($)try{const d=await fromUuid($);if(d){if(d instanceof TokenDocument)T={token:d==null?void 0:d.id,actor:(n=d==null?void 0:d.actor)==null?void 0:n.id,scene:(r=d==null?void 0:d.parent)==null?void 0:r.id,alias:(d==null?void 0:d.name)||((s=d==null?void 0:d.actor)==null?void 0:s.name)};else if(d instanceof Actor){const M=(o=game.scenes)==null?void 0:o.active;if(M){const w=(i=M.tokens)==null?void 0:i.filter(L=>{var k;return((k=L.actor)==null?void 0:k.id)===d.id});if(w&&w.length>0){const L=w[0];T={token:L.id,actor:d.id,scene:M.id,alias:L.name||d.name}}else T={actor:d.id,alias:d.name}}}}}catch(d){ModuleLogger.warn(`Failed to process speaker: ${d}`)}if(b)try{const d=await fromUuid(b);if(!d)throw new Error(`Item with UUID ${b} not found`);const M=d;ModuleLogger.info(`Creating chat message for item: ${M.name}`);let w,L=!1,k=null;if(U)try{const q=await fromUuid(U);if(q){if(q instanceof TokenDocument)k=q,L=!0,ModuleLogger.info(`Target token acquired: ${q.name}`);else if(q instanceof Actor){const I=(t=game.scenes)==null?void 0:t.active;if(I){const S=(a=I.tokens)==null?void 0:a.filter(P=>{var x;return((x=P.actor)==null?void 0:x.id)===q.id});S&&S.length>0&&(k=S[0],L=!0,ModuleLogger.info(`Target token acquired from actor: ${S[0].name}`))}}if(L&&k&&canvas&&canvas.ready&&canvas.tokens&&((c=game.user)==null||c.targets.forEach(I=>I.setTarget(!1,{user:game.user,releaseOthers:!1,groupSelection:!1})),(u=game.user)==null||u.targets.clear(),k.id)){const I=canvas.tokens.get(k.id);I&&(I.setTarget(!0,{user:game.user,releaseOthers:!0,groupSelection:!1}),ModuleLogger.info(`Token targeted on canvas: ${I.name}`))}}}catch(q){ModuleLogger.warn(`Failed to process target: ${q}`)}if((l=M.system)!=null&&l.actionType){if(ModuleLogger.info(`Using D&D 5e item with action type: ${M.system.actionType}`),(g=M.system)!=null&&g.actionType){const q={configureDialog:!1,createMessage:!0,skipDialog:!0,fastForward:!0,consume:!1,speaker:T,target:k};L&&k&&(q.target=k);const I=Dialog.prototype.render;Dialog.prototype.render=function(...S){const P=I.apply(this,S);return setTimeout(()=>{if(this.element&&this.element.length){const x=this.element.find(".dialog-button.default");if(x.length)ModuleLogger.info("Auto-clicking default button in rendered dialog"),x.trigger("click");else{const O=this.element.find(".dialog-button").first();O.length&&(ModuleLogger.info("Auto-clicking first button in rendered dialog"),O.trigger("click"))}}},100),P};try{ModuleLogger.info(`Using item with dialog auto-click enabled: ${M.name}`);const S=await M.use(q);w=(S==null?void 0:S.id)||S,ModuleLogger.info(`Item used with use() method, should trigger Midi-QOL: ${M.name}`)}finally{Dialog.prototype.render=I,ModuleLogger.info("Restored original dialog methods after item use")}}else if(M.displayCard&&typeof M.displayCard=="function"){const q=await M.displayCard({createMessage:!0,speaker:T,...L?{target:k}:{}});w=q==null?void 0:q.id}}else if(typeof M.toChat=="function"){const q=L?{target:k}:{},I=await M.toChat(q);w=I==null?void 0:I.id}else if(typeof M.displayCard=="function"){const q=M.displayCard,I=await q({createMessage:!0,speaker:T,...L?{target:k}:{}});w=I==null?void 0:I.id}else{const q={user:(m=game.user)==null?void 0:m.id,speaker:T,content:`
                        <div class="item-card">
                        <div class="item-name">${M.name}</div>
                        <div class="item-image"><img src="${M.img}" width="50" height="50"/></div>
                        <div class="item-description">${((y=(f=M.system)==null?void 0:f.description)==null?void 0:y.value)||""}</div>
                        ${L?`<div class="item-target">Target: ${k==null?void 0:k.name}</div>`:""}
                        </div>
                    `,type:CONST.CHAT_MESSAGE_TYPES.OTHER,flavor:`Item: ${M.name}${L?` (Target: ${k==null?void 0:k.name})`:""}`},I=await ChatMessage.create(q);w=I==null?void 0:I.id}R={id:`item_display_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,chatMessageCreated:!0,itemDisplayed:{uuid:M.uuid,name:M.name,type:M.type,img:M.img},target:L?{uuid:k==null?void 0:k.uuid,name:k==null?void 0:k.name}:null,messageId:w},ModuleLogger.info(`Item chat message created with ID: ${w}`)}catch(d){ModuleLogger.error(`Error displaying item in chat: ${d}`),socketManager.send({type:"roll-result",requestId:D,success:!1,error:`Failed to display item in chat: ${d.message}`});return}else try{const d=new Roll(h);await d.evaluate(),N&&await d.toMessage({speaker:T,flavor:v||"",rollMode:p,whisper:C||[]}),R={id:`manual_${Date.now()}_${Math.random().toString(36).substring(2,15)}`,chatMessageCreated:!!N,roll:{formula:h,total:d.total,isCritical:d.terms.some(M=>{var w;return(w=M.results)==null?void 0:w.some(L=>L.result===d.terms[0].faces)}),isFumble:d.terms.some(M=>{var w;return(w=M.results)==null?void 0:w.some(L=>L.result===1)}),dice:d.dice.map(M=>({faces:M.faces,results:M.results.map(w=>({result:w.result,active:w.active}))})),timestamp:Date.now()}}}catch(d){ModuleLogger.error(`Error rolling formula: ${d}`),socketManager.send({type:"roll-result",requestId:D,success:!1,error:`Failed to roll formula: ${d.message}`});return}socketManager.send({type:"roll-result",requestId:D,success:!0,data:R})}catch(h){ModuleLogger.error(`Error in roll handler: ${h}`),socketManager.send({type:"roll-result",requestId:e.requestId,success:!1,error:h.message||"Unknown error occurred during roll"})}}),socketManager.onMessageType("get-sheet-html",async e=>{var n,r;ModuleLogger.info(`Received sheet HTML request for UUID: ${e.uuid}`);try{let s=null;if(e.uuid)s=await fromUuid(e.uuid);else if(e.selected){const i=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled;i&&i.length>0&&(e.actor?s=i[0].actor:s=i[0].document)}if(!s){ModuleLogger.error(`Entity not found for UUID: ${e.uuid}`),socketManager.send({type:"actor-sheet-html-response",requestId:e.requestId,data:{error:"Entity not found",uuid:e.uuid}});return}const o=(r=s.sheet)==null?void 0:r.render(!0);setTimeout(async()=>{try{let i=function(p){p.classList&&p.classList.length&&p.classList.forEach(d=>m.add(d)),p.id&&f.add(p.id);for(let d=0;d<p.children.length;d++)i(p.children[d])};if(!o.element||!o.element[0])throw new Error("Failed to render actor sheet");let t=o.element[0].outerHTML,a="";const c=String(o.appId);document.querySelectorAll("style[data-appid]").forEach(p=>{p.dataset.appid===c&&(a+=p.textContent+`
`)}),document.querySelectorAll(`style[id^="system-${s.type}"]`).forEach(p=>{a+=p.textContent+`
`});const g=document.createElement("div");g.innerHTML=t;const m=new Set,f=new Set;i(g);const y=Array.from(m),h=Array.from(f);ModuleLogger.debug(`Extracted ${y.length} unique classes and ${h.length} unique IDs`);const b=document.querySelectorAll("style"),v=document.querySelectorAll('link[rel="stylesheet"]');b.forEach(p=>{if(p.dataset.appid&&p.dataset.appid===c)return;const d=p.textContent||"";(y.some(w=>d.includes(`.${w}`))||h.some(w=>d.includes(`#${w}`))||d.includes(".window-app")||d.includes(".sheet")||d.includes(".actor-sheet")||d.includes(`.${s.type}-sheet`))&&(ModuleLogger.debug("Adding relevant inline style"),a+=d+`
`)});const N=Array.from(v).map(async p=>{try{const d=p.getAttribute("href");if(!d||d.includes("fonts.googleapis.com"))return"";ModuleLogger.debug(`Fetching external CSS from: ${d}`);const M=d.startsWith("http")?d:d.startsWith("/")?`${window.location.origin}${d}`:`${window.location.origin}/${d}`,w=await fetch(M);return w.ok?await w.text():(ModuleLogger.warn(`Failed to fetch CSS: ${M}, status: ${w.status}`),"")}catch(d){return ModuleLogger.warn(`Failed to fetch external CSS: ${d}`),""}}),$=window.location.origin;ModuleLogger.debug(`Base URL for fetching CSS: ${$}`);const U=[`${$}/css/style.css`,`${$}/styles/style.css`,`${$}/styles/foundry.css`,`${$}/ui/sheets.css`,`${$}/game/styles/foundry.css`,`${$}/game/ui/sheets.css`,`${$}/systems/${game.system.id}/system.css`,`${$}/systems/${game.system.id}/styles/system.css`,`${$}/game/systems/${game.system.id}/system.css`,`${$}/game/systems/${game.system.id}/styles/system.css`];ModuleLogger.debug("All stylesheet links in document:",Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(p=>p.getAttribute("href")).filter(Boolean));const C=Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(p=>p.getAttribute("href")).filter(p=>p!==null&&!p.includes("fonts.googleapis.com")&&!p.includes("//"));U.push(...C),ModuleLogger.debug("All style elements in document:",document.querySelectorAll("style").length);const D=U.map(async p=>{try{ModuleLogger.debug(`Fetching core CSS from: ${p}`);const d=await fetch(p);return d.ok?(ModuleLogger.info(`Successfully loaded CSS from: ${p}`),await d.text()):(ModuleLogger.warn(`Failed to fetch CSS: ${p}, status: ${d.status}`),"")}catch(d){return ModuleLogger.warn(`Failed to fetch core CSS: ${d}`),""}}),R=[...N,...D];(await Promise.all(R)).forEach(p=>{a+=p+`
`}),a.length<100&&(ModuleLogger.warn("CSS fetch failed or returned minimal content. Adding fallback styles."),a+=`
        /* Fallback styles for actor sheet */
        .window-app {
            font-family: "Signika", sans-serif;
            background: #f0f0e0;
            border-radius: 5px;
            box-shadow: 0 0 20px #000;
            color: #191813;
        }
        .window-content {
            background: rgba(255, 255, 240, 0.9);
            padding: 8px;
            overflow-y: auto;
            background: url(${window.location.origin}/ui/parchment.jpg) repeat;
        }
        input, select, textarea {
            border: 1px solid #7a7971;
            background: rgba(255, 255, 255, 0.8);
        }
        button {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #7a7971;
            border-radius: 3px;
            cursor: pointer;
        }
        .profile-img {
            border: none;
            max-width: 100%;
            max-height: 220px;
        }
        `),ModuleLogger.debug(`Collected CSS: ${a.length} bytes`),t=t.replace(/src="([^"]+)"/g,(p,d)=>d.startsWith("http")?p:d.startsWith("/")?`src="${window.location.origin}${d}"`:`src="${window.location.origin}/${d}"`),a=a.replace(/url\(['"]?([^'")]+)['"]?\)/g,(p,d)=>d.startsWith("http")||d.startsWith("data:")?p:d.startsWith("/")?`url('${window.location.origin}${d}')`:`url('${window.location.origin}/${d}')`),o.close(),socketManager.send({type:"actor-sheet-html-response",requestId:e.requestId,data:{html:t,css:a,uuid:e.uuid}}),ModuleLogger.debug(`Sent actor sheet HTML response with requestId: ${e.requestId}`),ModuleLogger.debug(`HTML length: ${t.length}, CSS length: ${a.length}`)}catch(i){ModuleLogger.error("Error capturing actor sheet HTML:",i),socketManager.send({type:"actor-sheet-html-response",requestId:e.requestId,data:{error:"Failed to capture actor sheet HTML",uuid:e.uuid}}),o&&typeof o.close=="function"&&o.close()}},500)}catch(s){ModuleLogger.error("Error rendering actor sheet:",s),socketManager.send({type:"actor-sheet-html-response",requestId:e.requestId,data:{error:"Failed to render actor sheet",uuid:e.uuid}})}}),socketManager.onMessageType("get-macros",async e=>{var n;ModuleLogger.info("Received request for macros");try{const r=((n=game.macros)==null?void 0:n.contents.map(s=>{var o,i;return{uuid:s.uuid,id:s.id,name:s.name,type:s.type||((o=s.data)==null?void 0:o.type)||"unknown",author:((i=s.author)==null?void 0:i.name)||"unknown",command:s.command||"",img:s.img,scope:s.scope,canExecute:s.canExecute}}))||[];socketManager.send({type:"macros-list",requestId:e.requestId,macros:r})}catch(r){ModuleLogger.error("Error getting macros list:",r),socketManager.send({type:"macros-list",requestId:e.requestId,error:r.message,macros:[]})}}),socketManager.onMessageType("get-hotbar",async e=>{var n,r,s,o;ModuleLogger.info("Received request for hotbar data");try{const i=((n=ui.hotbar)==null?void 0:n.page)||1,t=[];ModuleLogger.info(`Current hotbar page: ${i}`);const a=((r=game.user)==null?void 0:r.data)||{};ModuleLogger.info(`User data keys: ${Object.keys(a)}`);const c=((s=a.flags)==null?void 0:s.hotbar)||{},u=a.hotbar||{};ModuleLogger.info(`Hotbar flags keys: ${Object.keys(c)}`),ModuleLogger.info(`Direct hotbar keys: ${Object.keys(u)}`);for(let l=1;l<=10;l++){const g=(i-1)*10+l,m=c[g]||u[g];if(ModuleLogger.info(`Slot ${l} (index ${g}): macroId = ${m}`),m){const f=(o=game.macros)==null?void 0:o.get(m);f?t.push({slot:l,uuid:f.uuid,id:f.id,name:f.name,type:f.type||"unknown",img:f.img,command:f.command||"",canExecute:f.canExecute}):(ModuleLogger.info(`Macro with ID ${m} not found`),t.push({slot:l,macroId:m,notFound:!0}))}else t.push({slot:l,empty:!0})}socketManager.send({type:"hotbar-data",requestId:e.requestId,currentPage:i,hotbar:t})}catch(i){ModuleLogger.error("Error getting hotbar data:",i),socketManager.send({type:"hotbar-data",requestId:e.requestId,error:i.message,hotbar:[]})}}),socketManager.onMessageType("execute-macro",async e=>{ModuleLogger.info(`Received request to execute macro: ${e.uuid}`);try{if(!e.uuid)throw new Error("Macro UUID is required");const n=await fromUuid(e.uuid);if(!n)throw new Error(`Macro not found with UUID: ${e.uuid}`);if(!(n instanceof CONFIG.Macro.documentClass))throw new Error(`Entity with UUID ${e.uuid} is not a macro`);if(!n.canExecute)throw new Error(`Macro '${n.name}' cannot be executed by the current user`);const r=e.args||{};let s;typeof r=="object"?s=await n.execute({args:r}):s=await n.execute(),socketManager.send({type:"macro-execution-result",requestId:e.requestId,uuid:e.uuid,success:!0,result:typeof s=="object"?s:{value:s}})}catch(n){ModuleLogger.error("Error executing macro:",n),socketManager.send({type:"macro-execution-result",requestId:e.requestId,uuid:e.uuid||"",success:!1,error:n.message})}}),socketManager.onMessageType("get-encounters",async e=>{var n;ModuleLogger.info("Received request for encounters");try{const r=((n=game.combats)==null?void 0:n.contents.map(s=>{var o;return{id:s.id,name:s.name,round:s.round,turn:s.turn,current:s.id===((o=game.combat)==null?void 0:o.id),combatants:s.combatants.contents.map(i=>{var t,a;return{id:i.id,name:i.name,tokenUuid:(t=i.token)==null?void 0:t.uuid,actorUuid:(a=i.actor)==null?void 0:a.uuid,img:i.img,initiative:i.initiative,hidden:i.hidden,defeated:i.isDefeated}})}}))||[];socketManager.send({type:"encounters-list",requestId:e.requestId,encounters:r})}catch(r){ModuleLogger.error("Error getting encounters list:",r),socketManager.send({type:"encounters-list",requestId:e.requestId,error:r.message,encounters:[]})}}),socketManager.onMessageType("start-encounter",async e=>{var n,r,s;ModuleLogger.info("Received request to start encounter with options:",e);try{const o=await Combat.create({name:e.name||"New Encounter"});if(o){if(await o.startCombat(),e.tokenUuids&&e.tokenUuids.length>0){const t=[];for(const a of e.tokenUuids)try{const c=await fromUuid(a);c&&t.push({tokenId:c.id??"",sceneId:c.parent.id})}catch(c){ModuleLogger.warn(`Failed to add token ${a} to combat:`,c)}t.length>0&&await o.createEmbeddedDocuments("Combatant",t)}let i=new Set;if(e.startWithPlayers){const t=(n=game.scenes)==null?void 0:n.viewed;if(t){const c=(((r=t.tokens)==null?void 0:r.filter(u=>!!u.actor&&u.actor.hasPlayerOwner))??[]).map(u=>(i.add(u.id),{tokenId:u.id,sceneId:t.id}));c.length>0&&await o.createEmbeddedDocuments("Combatant",c)}}if(e.startWithSelected){const t=((s=canvas==null?void 0:canvas.tokens)==null?void 0:s.controlled.filter(a=>!i.has(a.id)).map(a=>({tokenId:a.id,sceneId:a.scene.id})))??[];t.length>0&&await o.createEmbeddedDocuments("Combatant",t)}e.rollNPC&&await o.rollNPC(),e.rollAll&&await o.rollAll(),await o.activate(),socketManager.send({type:"encounter-started",requestId:e.requestId,encounterId:o.id,encounter:{id:o.id,name:o.name,round:o.round,turn:o.turn,combatants:o.combatants.contents.map(t=>{var a,c;return{id:t.id,name:t.name,tokenUuid:(a=t.token)==null?void 0:a.uuid,actorUuid:(c=t.actor)==null?void 0:c.uuid,img:t.img,initiative:t.initiative,hidden:t.hidden,defeated:t.isDefeated}})}})}else throw new Error("Failed to create encounter")}catch(o){ModuleLogger.error("Error starting encounter:",o),socketManager.send({type:"encounter-started",requestId:e.requestId,error:o.message})}}),socketManager.onMessageType("encounter-next-turn",async e=>{var n,r,s,o,i;ModuleLogger.info(`Received request for next turn in encounter: ${e.encounterId||"active"}`);try{const t=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!t)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await t.nextTurn(),socketManager.send({type:"encounter-navigation",requestId:e.requestId,encounterId:t.id,action:"nextTurn",currentTurn:t.turn,currentRound:t.round,actorTurn:(s=(r=t.combatant)==null?void 0:r.actor)==null?void 0:s.uuid,tokenTurn:(i=(o=t.combatant)==null?void 0:o.token)==null?void 0:i.uuid,encounter:{id:t.id,name:t.name,round:t.round,turn:t.turn}})}catch(t){ModuleLogger.error("Error advancing to next turn:",t),socketManager.send({type:"encounter-navigation",requestId:e.requestId,error:t.message})}}),socketManager.onMessageType("encounter-next-round",async e=>{var n,r,s,o,i;ModuleLogger.info(`Received request for next round in encounter: ${e.encounterId||"active"}`);try{const t=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!t)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await t.nextRound(),socketManager.send({type:"encounter-navigation",requestId:e.requestId,encounterId:t.id,action:"nextRound",currentTurn:t.turn,currentRound:t.round,actorTurn:(s=(r=t.combatant)==null?void 0:r.actor)==null?void 0:s.uuid,tokenTurn:(i=(o=t.combatant)==null?void 0:o.token)==null?void 0:i.uuid,encounter:{id:t.id,name:t.name,round:t.round,turn:t.turn}})}catch(t){ModuleLogger.error("Error advancing to next round:",t),socketManager.send({type:"encounter-navigation",requestId:e.requestId,error:t.message})}}),socketManager.onMessageType("encounter-previous-turn",async e=>{var n,r,s,o,i;ModuleLogger.info(`Received request for previous turn in encounter: ${e.encounterId||"active"}`);try{const t=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!t)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await t.previousTurn(),socketManager.send({type:"encounter-navigation",requestId:e.requestId,encounterId:t.id,action:"previousTurn",currentTurn:t.turn,currentRound:t.round,actorTurn:(s=(r=t.combatant)==null?void 0:r.actor)==null?void 0:s.uuid,tokenTurn:(i=(o=t.combatant)==null?void 0:o.token)==null?void 0:i.uuid,encounter:{id:t.id,name:t.name,round:t.round,turn:t.turn}})}catch(t){ModuleLogger.error("Error going back to previous turn:",t),socketManager.send({type:"encounter-navigation",requestId:e.requestId,error:t.message})}}),socketManager.onMessageType("encounter-previous-round",async e=>{var n,r,s,o,i;ModuleLogger.info(`Received request for previous round in encounter: ${e.encounterId||"active"}`);try{const t=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!t)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");await t.previousRound(),socketManager.send({type:"encounter-navigation",requestId:e.requestId,encounterId:t.id,action:"previousRound",currentTurn:t.turn,currentRound:t.round,actorTurn:(s=(r=t.combatant)==null?void 0:r.actor)==null?void 0:s.uuid,tokenTurn:(i=(o=t.combatant)==null?void 0:o.token)==null?void 0:i.uuid,encounter:{id:t.id,name:t.name,round:t.round,turn:t.turn}})}catch(t){ModuleLogger.error("Error going back to previous round:",t),socketManager.send({type:"encounter-navigation",requestId:e.requestId,error:t.message})}}),socketManager.onMessageType("end-encounter",async e=>{var n,r;ModuleLogger.info(`Received request to end encounter: ${e.encounterId}`);try{let s=e.encounterId;s||(s=(n=game.combat)==null?void 0:n.id);const o=(r=game.combats)==null?void 0:r.get(s);if(!o)throw new Error("No encounter not found");await o.delete(),socketManager.send({type:"encounter-ended",requestId:e.requestId,encounterId:s,message:"Encounter successfully ended"})}catch(s){ModuleLogger.error("Error ending encounter:",s),socketManager.send({type:"encounter-ended",requestId:e.requestId,error:s.message})}}),socketManager.onMessageType("add-to-encounter",async e=>{var n,r,s,o,i;ModuleLogger.info(`Received add-to-encounter request for encounter: ${e.encounterId}`);try{const t=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!t)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const a=[],c=[];if(e.uuids&&Array.isArray(e.uuids))for(const u of e.uuids)try{const l=await fromUuid(u);if(!l){c.push({uuid:u,reason:"Entity not found"});continue}if(l.documentName==="Token"){const g=l,m={tokenId:g.id,sceneId:(r=g.parent)==null?void 0:r.id};await t.createEmbeddedDocuments("Combatant",[m]),a.push(u)}else if(l.documentName==="Actor"){const g=(s=game.scenes)==null?void 0:s.viewed;if(g){const m=(o=g.tokens)==null?void 0:o.find(f=>{var y;return((y=f.actor)==null?void 0:y.id)===l.id});if(m){const f={tokenId:m.id,sceneId:g.id};await t.createEmbeddedDocuments("Combatant",[f]),a.push(u)}else c.push({uuid:u,reason:"No token found for this actor in the current scene"})}else c.push({uuid:u,reason:"No active scene"})}else c.push({uuid:u,reason:"Entity must be a Token or Actor"})}catch(l){c.push({uuid:u,reason:l.message})}if(e.selected===!0){const u=((i=canvas==null?void 0:canvas.tokens)==null?void 0:i.controlled)||[];for(const l of u)try{if(!t.combatants.find(g=>{var m,f,y;return((m=g.token)==null?void 0:m.id)===l.id&&((y=(f=g.combat)==null?void 0:f.scene)==null?void 0:y.id)===l.scene.id})){const g={tokenId:l.id,sceneId:l.scene.id};await t.createEmbeddedDocuments("Combatant",[g]),a.push(l.document.uuid)}}catch(g){c.push({uuid:l.document.uuid,reason:g.message})}}e.rollInitiative===!0&&a.length>0&&t.rollAll(),socketManager.send({type:"add-to-encounter-result",requestId:e.requestId,encounterId:t.id,added:a,failed:c})}catch(t){ModuleLogger.error("Error adding to encounter:",t),socketManager.send({type:"add-to-encounter-result",requestId:e.requestId,error:t.message})}}),socketManager.onMessageType("remove-from-encounter",async e=>{var n,r;ModuleLogger.info(`Received remove-from-encounter request for encounter: ${e.encounterId}`);try{const s=e.encounterId?(n=game.combats)==null?void 0:n.get(e.encounterId):game.combat;if(!s)throw new Error(e.encounterId?`Encounter with ID ${e.encounterId} not found`:"No active encounter");const o=[],i=[],t=[];if(e.uuids&&Array.isArray(e.uuids))for(const a of e.uuids)try{const c=await fromUuid(a);if(!c){i.push({uuid:a,reason:"Entity not found"});continue}let u=!1;if(c.documentName==="Token"){const l=s.combatants.find(g=>{var m,f,y,h;return((m=g.token)==null?void 0:m.id)===c.id&&((y=(f=g.combat)==null?void 0:f.scene)==null?void 0:y.id)===((h=c.parent)==null?void 0:h.id)});l&&(t.push(l.id),u=!0)}else if(c.documentName==="Actor"){const l=s.combatants.filter(g=>{var m;return((m=g.actor)==null?void 0:m.id)===c.id});l.length>0&&(t.push(...l.map(g=>g.id)),u=!0)}u?o.push(a):i.push({uuid:a,reason:"No combatant found for this entity"})}catch(c){i.push({uuid:a,reason:c.message})}if(e.selected===!0){const a=((r=canvas==null?void 0:canvas.tokens)==null?void 0:r.controlled)||[];for(const c of a){const u=s.combatants.find(l=>l.tokenId===c.id&&l.sceneId===c.scene.id);u&&(t.push(u.id),o.push(c.document.uuid))}}if(t.length>0){const a=t.filter(c=>c!==null);a.length>0&&await s.deleteEmbeddedDocuments("Combatant",a)}socketManager.send({type:"remove-from-encounter-result",requestId:e.requestId,encounterId:s.id,removed:o,failed:i})}catch(s){ModuleLogger.error("Error removing from encounter:",s),socketManager.send({type:"remove-from-encounter-result",requestId:e.requestId,error:s.message})}}),socketManager.onMessageType("kill-entity",async e=>{var n,r,s;ModuleLogger.info(`Received kill request for UUID: ${e.uuid}`);try{const o=[];if(e.uuid){const t=await fromUuid(e.uuid);if(t)o.push(t);else throw new Error(`Entity not found: ${e.uuid}`)}else if(e.selected){const t=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const a of t)a.document&&o.push(a.document)}if(o.length===0)throw new Error("No entities found to mark as defeated");const i=[];for(const t of o){let a=!1,c="";if(t.documentName==="Token"){const u=t,l=u.actor;if(!l)throw new Error("Token has no associated actor");const g=game.combat;if(g){const m=g.combatants.find(f=>{var y,h,b,v;return((y=f.token)==null?void 0:y.id)===u.id&&((b=(h=f.token)==null?void 0:h.parent)==null?void 0:b.id)===((v=u.parent)==null?void 0:v.id)});m&&(await m.update({defeated:!0}),ModuleLogger.info("Marked token as defeated in combat"))}try{hasProperty(l,"system.attributes.hp")?await l.update({"system.attributes.hp.value":0}):hasProperty(l,"system.health")?await l.update({"system.health.value":0}):hasProperty(l,"system.hp")?await l.update({"system.hp.value":0}):hasProperty(l,"data.attributes.hp")&&await l.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(m){ModuleLogger.warn(`Could not set HP to 0: ${m}`)}try{const m=(r=CONFIG.statusEffects)==null?void 0:r.find(f=>f.id==="dead"||f.id==="unconscious"||f.id==="defeated");m?(await u.toggleActiveEffect(m),ModuleLogger.info(`Added ${m.id} status effect to token`)):ModuleLogger.warn("No dead status effect found")}catch(m){ModuleLogger.warn(`Could not apply status effect: ${m}`)}a=!0,c="Token marked as defeated, HP set to 0, and dead effect applied"}else if(t.documentName==="Actor"){const u=t;let l=0;const g=game.scenes;if(g!=null&&g.viewed){const f=g.viewed.tokens.filter(y=>{var h;return((h=y.actor)==null?void 0:h.id)===u.id});for(const y of f)try{const h=(s=CONFIG.statusEffects)==null?void 0:s.find(b=>b.id==="dead"||b.id==="unconscious"||b.id==="defeated");h&&(await y.toggleActiveEffect(h),l++)}catch(h){ModuleLogger.warn(`Could not apply status effect to token: ${h}`)}}const m=game.combat;if(m){const f=m.combatants.filter(y=>{var h;return((h=y.actor)==null?void 0:h.id)===u.id});f.length>0&&(await Promise.all(f.map(y=>y.update({defeated:!0}))),ModuleLogger.info(`Marked ${f.length} combatants as defeated`))}try{hasProperty(u,"system.attributes.hp")?await u.update({"system.attributes.hp.value":0}):hasProperty(u,"system.health")?await u.update({"system.health.value":0}):hasProperty(u,"system.hp")?await u.update({"system.hp.value":0}):hasProperty(u,"data.attributes.hp")&&await u.update({"data.attributes.hp.value":0}),ModuleLogger.info("Set actor HP to 0")}catch(f){ModuleLogger.warn(`Could not set HP to 0: ${f}`)}a=!0,c=`Actor marked as defeated, HP set to 0, and dead effect applied to ${l} tokens`}else throw new Error(`Cannot mark entity type ${t.documentName} as defeated`);i.push({uuid:t.uuid,success:a,message:c})}socketManager.send({type:"kill-entity-result",requestId:e.requestId,results:i})}catch(o){ModuleLogger.error("Error marking entities as defeated:",o),socketManager.send({type:"kill-entity-result",requestId:e.requestId,success:!1,error:o.message})}}),socketManager.onMessageType("decrease-attribute",async e=>{var n;ModuleLogger.info(`Received decrease attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const r=[];if(e.selected){const o=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const i of o)i.actor&&r.push(i.actor)}else if(e.uuid){const o=await fromUuid(e.uuid);o&&r.push(o)}if(r.length===0)throw new Error("No entities found to modify");const s=[];for(const o of r){const i=getProperty(o,e.attribute);if(typeof i!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof i}`);const t=i-e.amount,a={};a[e.attribute]=t,await o.update(a),s.push({uuid:o.uuid,attribute:e.attribute,oldValue:i,newValue:t})}socketManager.send({type:"modify-attribute-result",requestId:e.requestId,results:s,success:!0})}catch(r){ModuleLogger.error("Error decreasing attribute:",r),socketManager.send({type:"modify-attribute-result",requestId:e.requestId,success:!1,error:r.message})}}),socketManager.onMessageType("increase-attribute",async e=>{var n;ModuleLogger.info(`Received increase attribute request for attribute: ${e.attribute}, amount: ${e.amount}`);try{if(!e.uuid&&!e.selected)throw new Error("UUID or selected is required");if(!e.attribute)throw new Error("Attribute path is required");if(typeof e.amount!="number")throw new Error("Amount must be a number");const r=[];if(e.selected){const o=((n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled)||[];for(const i of o)i.actor&&r.push(i.actor)}else if(e.uuid){const o=await fromUuid(e.uuid);o&&r.push(o)}if(r.length===0)throw new Error("No entities found to modify");const s=[];for(const o of r){const i=getProperty(o,e.attribute);if(typeof i!="number")throw new Error(`Attribute ${e.attribute} is not a number, found: ${typeof i}`);const t=i+e.amount,a={};a[e.attribute]=t,await o.update(a),s.push({uuid:o.uuid,attribute:e.attribute,oldValue:i,newValue:t})}socketManager.send({type:"modify-attribute-result",requestId:e.requestId,results:s,success:!0})}catch(r){ModuleLogger.error("Error increasing attribute:",r),socketManager.send({type:"modify-attribute-result",requestId:e.requestId,success:!1,error:r.message})}}),socketManager.onMessageType("give-item",async e=>{var n,r,s,o;ModuleLogger.info(`Received give item request from ${e.fromUuid} to ${e.toUuid}`);try{if(!e.toUuid&&!e.selected)throw new Error("Target UUID or selected is required");if(!e.itemUuid)throw new Error("Item UUID is required");let i=null;if(e.fromUuid&&(i=await fromUuid(e.fromUuid),(i==null?void 0:i.documentName)!=="Actor"))throw new Error(`Source entity must be an Actor, got ${i==null?void 0:i.documentName}`);e.selected&&(e.toUuid=(s=(r=(n=canvas==null?void 0:canvas.tokens)==null?void 0:n.controlled[0])==null?void 0:r.actor)==null?void 0:s.uuid);const t=await fromUuid(e.toUuid);if(!t)throw new Error(`Target entity not found: ${e.toUuid}`);if(t.documentName!=="Actor")throw new Error(`Target entity must be an Actor, got ${t.documentName}`);const a=await fromUuid(e.itemUuid);if(!a)throw new Error(`Item not found: ${e.itemUuid}`);if(a.documentName!=="Item")throw new Error(`Entity must be an Item, got ${a.documentName}`);if(e.fromUuid&&((o=a.parent)==null?void 0:o.id)!==i.id)throw new Error(`Item ${e.itemUuid} does not belong to source actor ${e.fromUuid}`);const c=a.toObject();if(delete c._id,e.quantity&&typeof e.quantity=="number"){if(c.system&&c.system.quantity){const l=c.system.quantity;c.system.quantity=e.quantity,e.fromUuid&&(e.quantity>=l?await a.delete():await a.update({"system.quantity":l-e.quantity}))}}else e.fromUuid&&await a.delete();const u=await t.createEmbeddedDocuments("Item",[c]);socketManager.send({type:"give-item-result",requestId:e.requestId,fromUuid:e.fromUuid,selected:e.selected,toUuid:e.toUuid,quantity:e.quantity,itemUuid:e.itemUuid,newItemId:u[0].id,success:!0})}catch(i){ModuleLogger.error("Error giving item:",i),socketManager.send({type:"give-item-result",requestId:e.requestId,selected:e.selected,fromUuid:e.fromUuid||"",toUuid:e.toUuid||"",quantity:e.quantity,itemUuid:e.itemUuid||"",success:!1,error:i.message})}}),socketManager.onMessageType("execute-js",async data=>{ModuleLogger.info("Received execute-js request:",data);try{const{script,requestId}=data;if(!script||typeof script!="string")throw new Error("Invalid script provided");let result;try{result=await(async()=>eval(`(async () => { ${script} })()`))()}catch(e){const n=e instanceof Error?e.message:String(e);throw new Error(`Error executing script: ${n}`)}socketManager.send({type:"execute-js-result",requestId,success:!0,result})}catch(e){ModuleLogger.error("Error in execute-js handler:",e),socketManager.send({type:"execute-js-result",requestId:data.requestId,success:!1,error:e.message})}}),socketManager.onMessageType("select-entities",async e=>{var n,r,s,o,i,t,a;ModuleLogger.info("Received select entities request:",e);try{const c=(n=game.scenes)==null?void 0:n.active;if(!c)throw new Error("No active scene found");e.overwrite&&((r=canvas==null?void 0:canvas.tokens)==null||r.releaseAll());let u=[];if(e.all&&(u=((s=c.tokens)==null?void 0:s.contents)||[]),e.uuids&&Array.isArray(e.uuids)){const l=((o=c.tokens)==null?void 0:o.filter(g=>e.uuids.includes(g.uuid)))||[];u=[...u,...l]}if(e.name){const l=((i=c.tokens)==null?void 0:i.filter(g=>{var m,f;return((m=g.name)==null?void 0:m.toLowerCase())===((f=e.name)==null?void 0:f.toLowerCase())}))||[];u=[...u,...l]}if(e.data){const l=((t=c.tokens)==null?void 0:t.filter(g=>Object.entries(e.data).every(([m,f])=>{if(m.startsWith("actor.")&&g.actor){const h=m.replace("actor.","");return getProperty(g.actor,h)===f}const y=g.toObject();return getProperty(y,m)===f})))||[];u=[...u,...l]}if(u.length===0)throw new Error("No matching entities found");for(const l of u){const g=l.id?(a=canvas==null?void 0:canvas.tokens)==null?void 0:a.get(l.id):null;g&&g.control({releaseOthers:!1})}socketManager.send({type:"select-entities-result",requestId:e.requestId,success:!0,count:u.length,message:`${u.length} entities selected`})}catch(c){ModuleLogger.error("Error selecting entities:",c),socketManager.send({type:"select-entities-result",requestId:e.requestId,success:!1,error:c.message})}}),socketManager.onMessageType("get-selected-entities",async e=>{var n,r;ModuleLogger.info("Received get selected entities request:",e);try{if(!((n=game.scenes)==null?void 0:n.active))throw new Error("No active scene found");const i=(((r=canvas==null?void 0:canvas.tokens)==null?void 0:r.controlled)||[]).map(t=>{var a;return{tokenUuid:t.document.uuid,actorUuid:((a=t.actor)==null?void 0:a.uuid)||null}});socketManager.send({type:"selected-entities-result",requestId:e.requestId,success:!0,selected:i})}catch(s){ModuleLogger.error("Error getting selected entities:",s),socketManager.send({type:"selected-entities-result",requestId:e.requestId,success:!1,error:s.message})}}),socketManager.onMessageType("get-file-system",async e=>{ModuleLogger.info("Received get file system request:",e);try{const n=e.path||"",r=e.source||"data",s=!!e.recursive,o=await FilePicker.browse(r,n),i=Array.isArray(o.dirs)?o.dirs.map(u=>({name:u.split("/").pop()||u,path:u,type:"directory"})):[],t=Array.isArray(o.files)?o.files.map(u=>({name:u.split("/").pop()||u,path:u,type:"file"})):[];let a=[];if(s&&i.length>0)for(const u of i)try{const l=await FilePicker.browse(r,u.path),g=Array.isArray(l.dirs)?l.dirs.map(f=>({name:f.split("/").pop()||f,path:f,type:"directory"})):[],m=Array.isArray(l.files)?l.files.map(f=>({name:f.split("/").pop()||f,path:f,type:"file"})):[];if(a=a.concat(g,m),s===!0&&g.length>0&&u.path.split("/").length<3)for(const f of g)try{const y=await FilePicker.browse(r,f.path),h=Array.isArray(y.dirs)?y.dirs.map(v=>({name:v.split("/").pop()||v,path:v,type:"directory"})):[],b=Array.isArray(y.files)?y.files.map(v=>({name:v.split("/").pop()||v,path:v,type:"file"})):[];a=a.concat(h,b)}catch(y){ModuleLogger.error(`Error processing deep subdirectory ${f.path}:`,y)}}catch(l){ModuleLogger.error(`Error processing subdirectory ${u.path}:`,l)}const c=[...i,...t];s&&c.push(...a),socketManager.send({type:"file-system-result",requestId:e.requestId,success:!0,path:n,source:r,results:c,recursive:s})}catch(n){ModuleLogger.error("Error getting file system:",n),socketManager.send({type:"file-system-result",requestId:e.requestId,success:!1,error:n.message})}}),socketManager.onMessageType("upload-file",async e=>{ModuleLogger.info("Received upload file request:",e);try{const{path:n,filename:r,source:s,fileData:o,mimeType:i,binaryData:t,overwrite:a}=e;if(!n||!r)throw new Error("Missing required parameters (path, filename)");let c;if(t){const m=new Uint8Array(t),f=new Blob([m],{type:i||"application/octet-stream"});c=new File([f],r,{type:i||"application/octet-stream"})}else if(o){const m=o.split(",")[1],f=atob(m),y=new Uint8Array(f.length);for(let b=0;b<f.length;b++)y[b]=f.charCodeAt(b);const h=new Blob([y],{type:i||"application/octet-stream"});c=new File([h],r,{type:i||"application/octet-stream"})}else throw new Error("Missing file data (either binaryData or fileData is required)");const u=s||"data";try{const m=n.split("/");let f="";for(const y of m){f=f?`${f}/${y}`:y;try{await FilePicker.createDirectory(u,f)}catch(h){if(!h.message.includes("already exists"))throw ModuleLogger.error("Error creating directory:",h),new Error(`Could not create directory: ${h.message}`)}}}catch(m){throw ModuleLogger.error("Error creating directory:",m),new Error(`Could not create directory: ${m.message}`)}let l=null;try{const m=n+"/"+r;l=await FilePicker.browse(u,m)}catch{}if(l&&!a)throw new Error("File already exists. Set overwrite to true to replace it.");const g=await FilePicker.upload(u,n,c);socketManager.send({type:"upload-file-result",requestId:e.requestId,success:!0,path:g&&typeof g=="object"&&"path"in g?g.path:n+"/"+r})}catch(n){ModuleLogger.error("Error uploading file:",n),socketManager.send({type:"upload-file-result",requestId:e.requestId,success:!1,error:n.message})}}),socketManager.onMessageType("download-file",async e=>{ModuleLogger.info("Received download file request:",e);try{const{path:n}=e;if(!n)throw new Error("Missing required parameter (path)");const r=await fetch(n.startsWith("http")?n:foundry.utils.getRoute(n));if(!r.ok)throw new Error(`Failed to download file: ${r.status} ${r.statusText}`);const s=await r.blob(),o=new FileReader,i=await new Promise((t,a)=>{o.onload=()=>t(o.result),o.onerror=a,o.readAsDataURL(s)});socketManager.send({type:"download-file-result",requestId:e.requestId,success:!0,path:n,fileData:i,filename:n.split("/").pop()||"file",mimeType:s.type})}catch(n){ModuleLogger.error("Error downloading file:",n),socketManager.send({type:"download-file-result",requestId:e.requestId,success:!1,error:n.message})}})}catch(e){ModuleLogger.error("Error initializing WebSocket:",e)}}Hooks.once("init",()=>{console.log(`Initializing ${moduleId}`),game.settings.register(moduleId,"wsRelayUrl",{name:"Local Relay Server URL",hint:"URL for the local FoundryVTT relay server (WebSocket connection)",scope:"world",config:!0,type:String,default:"ws://localhost:3001/ws",requiresReload:!0}),game.settings.register(moduleId,"apiKey",{name:"API Key",hint:"API Key for authentication with the local relay server (generated automatically)",scope:"world",config:!0,type:String,default:game.world.id,requiresReload:!0}),game.settings.register(moduleId,"logLevel",{name:"Log Level",hint:"Set the level of detail for module logging",scope:"world",config:!0,type:Number,choices:{0:"debug",1:"info",2:"warn",3:"error"},default:2}),game.settings.register(moduleId,"pingInterval",{name:"Ping Interval (seconds)",hint:"How often (in seconds) the module sends a ping to the local relay server to keep the connection alive.",scope:"world",config:!0,type:Number,default:30,range:{min:5,max:600,step:1},requiresReload:!0}),game.settings.register(moduleId,"reconnectMaxAttempts",{name:"Max Reconnect Attempts",hint:"Maximum number of times the module will try to reconnect after losing connection.",scope:"world",config:!0,type:Number,default:20,requiresReload:!0}),game.settings.register(moduleId,"reconnectBaseDelay",{name:"Reconnect Base Delay (ms)",hint:"Initial delay (in milliseconds) before the first reconnect attempt. Subsequent attempts use exponential backoff.",scope:"world",config:!0,type:Number,default:1e3,requiresReload:!0});const e=game.modules.get(moduleId);e.api={getWebSocketManager:()=>e.socketManager?e.socketManager:(ModuleLogger.warn("WebSocketManager requested but not initialized"),null),search:async(n,r)=>{if(!window.QuickInsert)return ModuleLogger.error("QuickInsert not available"),[];if(!window.QuickInsert.hasIndex){ModuleLogger.info("QuickInsert index not ready, forcing index creation");try{window.QuickInsert.forceIndex(),await new Promise(o=>setTimeout(o,500))}catch(o){ModuleLogger.error("Failed to force QuickInsert index:",o)}}let s=null;return r&&(s=o=>o.documentType===r),window.QuickInsert.search(n,s,100)},getByUuid:async n=>{try{return await fromUuid(n)}catch(r){return ModuleLogger.error("Error getting entity by UUID:",r),null}}}});Hooks.on("renderSettingsConfig",(e,n)=>{const r=n.find(`input[name="${moduleId}.apiKey"]`);r.length&&(r.attr("type","password"),r.on("change",s=>{const o=s.target.value;game.settings.set(moduleId,"apiKey",o).then(()=>{new Dialog({title:"Reload Required",content:"<p>The API Key has been updated. A reload is required for the changes to take effect. Would you like to reload now?</p>",buttons:{yes:{label:"Reload",callback:()=>window.location.reload()},no:{label:"Later"}},default:"yes"}).render(!0)})}))});Hooks.once("ready",()=>{setTimeout(()=>{initializeWebSocket()},1e3)});Hooks.on("createChatMessage",e=>{var n,r,s,o,i,t;if(e.isRoll&&((n=e.rolls)==null?void 0:n.length)>0){ModuleLogger.info(`Detected dice roll from ${((r=e.user)==null?void 0:r.name)||"unknown"}`);const a=e.id,c={id:a,messageId:e.id,user:{id:(s=e.user)==null?void 0:s.id,name:(o=e.user)==null?void 0:o.name},speaker:e.speaker,flavor:e.flavor||"",rollTotal:e.rolls[0].total,formula:e.rolls[0].formula,isCritical:e.rolls[0].isCritical||!1,isFumble:e.rolls[0].isFumble||!1,dice:(i=e.rolls[0].dice)==null?void 0:i.map(g=>({faces:g.faces,results:g.results.map(m=>({result:m.result,active:m.active}))})),timestamp:Date.now()},u=recentRolls.findIndex(g=>g.id===a);u!==-1?recentRolls[u]=c:(recentRolls.unshift(c),recentRolls.length>MAX_ROLLS_STORED&&(recentRolls.length=MAX_ROLLS_STORED));const l=game.modules.get(moduleId);(t=l.socketManager)!=null&&t.isConnected()&&l.socketManager.send({type:"roll-data",data:c})}});
//# sourceMappingURL=module.js.map
